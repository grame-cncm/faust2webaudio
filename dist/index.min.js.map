{"version":3,"sources":["webpack://Faust2WebAudio/webpack/universalModuleDefinition","webpack://Faust2WebAudio/webpack/bootstrap","webpack://Faust2WebAudio/./node_modules/@babel/runtime/regenerator/index.js","webpack://Faust2WebAudio/./node_modules/@babel/runtime/helpers/asyncToGenerator.js","webpack://Faust2WebAudio/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://Faust2WebAudio/./node_modules/regenerator-runtime/runtime.js","webpack://Faust2WebAudio/./node_modules/crypto-libraries/sha1.js","webpack://Faust2WebAudio/./src/utils.ts","webpack://Faust2WebAudio/./src/wasm/mixer32.wasm","webpack://Faust2WebAudio/./src/FaustWasmToScriptProcessor.ts","webpack://Faust2WebAudio/./src/FaustAudioWorkletProcessor.ts","webpack://Faust2WebAudio/./src/FaustAudioWorkletNode.ts","webpack://Faust2WebAudio/./src/FaustOfflineProcessor.ts","webpack://Faust2WebAudio/./src/Faust.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","fn","self","this","args","arguments","apply","err","undefined","obj","configurable","writable","runtime","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","method","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","invoke","result","__await","unwrapped","TypeError","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","Sha1","msg","options","opt","assign","msgFormat","outFormat","str","TextEncoder","encode","reduce","curr","String","fromCharCode","e","unescape","encodeURIComponent","utf8Encode","hexStr","replace","match","map","byte","parseInt","join","hexBytesToString","K","H","N","Math","ceil","M","Array","j","charCodeAt","pow","floor","W","ROTL","a","b","T","f","h","separator","x","y","z","ab2str","buf","Uint8Array","str2ab","ArrayBuffer","bufView","strLen","mixer32Module","WebAssembly","Module","sBase64","nBlocksSize","atob","nMod3","nMod4","nChr","sB64Enc","nInLen","nOutLen","taBytes","nUint24","nOutIdx","nInIdx","buffer","atoab","split","midiToFreq","note","remap","v","mn0","mx0","mn1","mx1","findPathClosure","findPath","address","k","createWasmImport","voices","memory","env","memoryBase","tableBase","_abs","abs","_acosf","acos","_asinf","asin","_atanf","atan","_atan2f","atan2","_ceilf","_cosf","cos","_expf","exp","_floorf","_fmodf","_logf","log","_log10f","log10","_max_f","max","_min_f","min","_remainderf","round","_powf","_roundf","fround","_sinf","sin","_sqrtf","sqrt","_tanf","tan","_acoshf","acosh","_asinhf","asinh","_atanhf","atanh","_coshf","cosh","_sinhf","sinh","_tanhf","tanh","_acos","_asin","_atan","_atan2","_ceil","_cos","_exp","_floor","_fmod","_log","_log10","_max_","_min_","_remainder","_pow","_round","_sin","_sqrt","_tan","_acosh","_asinh","_atanh","_cosh","_sinh","_tanh","table","Table","initial","element","createWasmMemory","voicesIn","dspMeta","effectMeta","bufferSize","memorySize","pow2limit","size","inputs","outputs","Memory","maximum","args2String","argStr","isArray","toArgv","argv","FaustWasmToScriptProcessor","faust","initNode","compiledDsp","dspInstance","effectInstance","mixerInstance","audioCtx","plotHandler","node","createScriptProcessor","message","destroyed","outputHandler","computeHandler","$ins","$outs","dspInChannnels","dspOutChannnels","fPitchwheelLabel","fCtrlLabel","fill","numIn","numOut","ptrSize","sampleSize","HEAP","HEAP32","Int32Array","HEAPF32","Float32Array","outputsTimer","outputsItems","inputsItems","$audioHeap","$$audioHeapInputs","$$audioHeapOutputs","$$audioHeapMixing","$audioHeapInputs","$audioHeapOutputs","$audioHeapMixing","$dsp","$mixing","fFreqLabel$","fGateLabel$","fGainLabel$","fDate","mixer","effect","dspVoices$","dspVoicesState","dspVoicesLevel","dspVoicesDate","kActiveVoice","kFreeVoice","kReleaseVoice","kNoVoice","$effect","pathTable$","$buffer","cachedEvents","updateOutputs","item","getParamValue","parseUI","ui","group","parseGroup","items","parseItems","parseItem","index","meta","midi","strMidi","trim","path","matched","getPlayingVoice","pitch","voice","oldestDatePlaying","Number","MAX_VALUE","allocVoice","instanceClear","getFreeVoice","voiceRelease","voicePlaying","oldestDateRelease","keyOn","channel","velocity","data","$","setParamValue","keyOff","allNotesOff","$gate","midiMessage","cmd","data1","data2","ctrlChange","pitchWheel","ctrl","wheel","pw","compute","input","inputBuffer","getChannelData","set","clearOutput","mixVoice","output","outputBuffer","dspOutput","setup","onaudioprocess","dspInChans","subarray","dspOutChans","endsWith","$voice","init","sampleRate","getSampleRate","getNumInputs","getNumOutputs","instanceInit","instanceConstants","instanceResetUserInterface","metadata","handler","declare","setOutputParamHandler","getOutputParamHandler","setComputeHandler","getComputeHandler","getParams","getJSON","label","JSON","stringify","getUI","destroy","getNode","optionsIn","bufferSizeIn","importObject","mixerObject","imports","print","console","Instance","instantiate","effectModule","dspModule","shaKey","FaustAudioWorkletProcessorWrapper","FaustConst","id","faustData","FaustAudioWorkletProcessor","AudioWorkletProcessor","callback","defaultValue","minValue","maxValue","params","super","handleMessage","port","close","processorOptions","instantiateWasm","onmessage","postMessage","mixerImports","parseItem2","val","process","parameters","chan","paramArray","events","printMemory","registerProcessor","FaustAudioWorkletNode","AudioWorkletNode","numberOfInputs","numberOfOutputs","channelCount","outputChannelCount","channelCountMode","channelInterpretation","onprocessorerror","automationRate","ctrlIn","valueIn","param","setValueAtTime","currentTime","FaustOfflineProcessor","plot","plotted","computed","Faust","debug","lib","libFaust","dspTable","workletProcessors","offlineProcessor","wasmLocation","dataLocation","logHandler","code","useWorklet","utils","compileCodes","getAudioWorkletNode","getScriptProcessorNode","inspect","compileCode","factoryName","argvIn","internalMemory","argsStr","time1","performance","now","fact","createDSPFactory","time2","wasm","getWasmModule","ui8Code","HEAP8","freeWasmModule","helpersCode","helper","errorMsg","getErrorAfterException","cleanupAfterException","strArgv","sha1","hash","version","effectCode","dspCompiledCode","effectCompiledCode","compiledCodes","dsp","compileDsp","expandCode","expand","expandDSP","expandedCode","codes","compile","json","parse","compiledDspWithCodes","indexOf","strProcessor","url","URL","createObjectURL","Blob","audioWorklet","addModule","deleteDsp","deleteAllDSPFactories","stringifyDspTable","strTable","strCode","btoa","parseDspTable","strCodes","getDiagram","generateAuxFiles","FS","readFile","encoding"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Faust2WebAudio\"] = factory();\n\telse\n\t\troot[\"Faust2WebAudio\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = require(\"regenerator-runtime\");\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* SHA-1 (FIPS 180-4) implementation in JavaScript                    (c) Chris Veness 2002-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/sha1.html                                                       */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * SHA-1 hash function reference implementation.\n *\n * This is an annotated direct implementation of FIPS 180-4, without any optimisations. It is\n * intended to aid understanding of the algorithm rather than for production use.\n *\n * While it could be used where performance is not critical, I would recommend using the Web\n * Cryptography API (developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest) for the browser,\n * or the crypto library (nodejs.org/api/crypto.html#crypto_class_hash) in Node.js.\n *\n * See csrc.nist.gov/groups/ST/toolkit/secure_hashing.html\n *     csrc.nist.gov/groups/ST/toolkit/examples.html\n */\nclass Sha1 {\n\n    /**\n     * Generates SHA-1 hash of string.\n     *\n     * @param   {string} msg - (Unicode) string to be hashed.\n     * @param   {Object} [options]\n     * @param   {string} [options.msgFormat=string] - Message format: 'string' for JavaScript string\n     *   (gets converted to UTF-8 for hashing); 'hex-bytes' for string of hex bytes ('616263'  'abc') .\n     * @param   {string} [options.outFormat=hex] - Output format: 'hex' for string of contiguous\n     *   hex bytes; 'hex-w' for grouping hex bytes into groups of (4 byte / 8 character) words.\n     * @returns {string} Hash of msg as hex character string.\n     *\n     * @example\n     *   import Sha1 from './sha1.js';\n     *   const hash = Sha1.hash('abc'); // 'a9993e364706816aba3e25717850c26c9cd0d89d'\n     */\n    static hash(msg, options) {\n        const defaults = { msgFormat: 'string', outFormat: 'hex' };\n        const opt = Object.assign(defaults, options);\n\n        switch (opt.msgFormat) {\n            default: // default is to convert string to UTF-8, as SHA only deals with byte-streams\n            case 'string':   msg = utf8Encode(msg);       break;\n            case 'hex-bytes':msg = hexBytesToString(msg); break; // mostly for running tests\n        }\n\n        // constants [4.2.1]\n        const K = [ 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6 ];\n\n        // initial hash value [5.3.1]\n        const H = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n\n        // PREPROCESSING [6.1.1]\n\n        msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [5.1.1]\n\n        // convert string msg into 512-bit/16-integer blocks arrays of ints [5.2.1]\n        const l = msg.length/4 + 2; // length (in 32-bit integers) of msg + 1 + appended length\n        const N = Math.ceil(l/16);  // number of 16-integer-blocks required to hold 'l' ints\n        const M = new Array(N);\n\n        for (let i=0; i<N; i++) {\n            M[i] = new Array(16);\n            for (let j=0; j<16; j++) {  // encode 4 chars per integer, big-endian encoding\n                M[i][j] = (msg.charCodeAt(i*64+j*4+0)<<24) | (msg.charCodeAt(i*64+j*4+1)<<16)\n                        | (msg.charCodeAt(i*64+j*4+2)<< 8) | (msg.charCodeAt(i*64+j*4+3)<< 0);\n            } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n        }\n        // add length (in bits) into final pair of 32-bit integers (big-endian) [5.1.1]\n        // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n        // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n        M[N-1][14] = ((msg.length-1)*8) / Math.pow(2, 32); M[N-1][14] = Math.floor(M[N-1][14]);\n        M[N-1][15] = ((msg.length-1)*8) & 0xffffffff;\n\n        // HASH COMPUTATION [6.1.2]\n\n        for (let i=0; i<N; i++) {\n            const W = new Array(80);\n\n            // 1 - prepare message schedule 'W'\n            for (let t=0;  t<16; t++) W[t] = M[i][t];\n            for (let t=16; t<80; t++) W[t] = Sha1.ROTL(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16], 1);\n\n            // 2 - initialise five working variables a, b, c, d, e with previous hash value\n            let a = H[0], b = H[1], c = H[2], d = H[3], e = H[4];\n\n            // 3 - main loop (use JavaScript '>>> 0' to emulate UInt32 variables)\n            for (let t=0; t<80; t++) {\n                const s = Math.floor(t/20); // seq for blocks of 'f' functions and 'K' constants\n                const T = (Sha1.ROTL(a, 5) + Sha1.f(s, b, c, d) + e + K[s] + W[t]) >>> 0;\n                e = d;\n                d = c;\n                c = Sha1.ROTL(b, 30) >>> 0;\n                b = a;\n                a = T;\n            }\n\n            // 4 - compute the new intermediate hash value (note 'addition modulo 2^32'  JavaScript\n            // '>>> 0' coerces to unsigned UInt32 which achieves modulo 2^32 addition)\n            H[0] = (H[0]+a) >>> 0;\n            H[1] = (H[1]+b) >>> 0;\n            H[2] = (H[2]+c) >>> 0;\n            H[3] = (H[3]+d) >>> 0;\n            H[4] = (H[4]+e) >>> 0;\n        }\n\n        // convert H0..H4 to hex strings (with leading zeros)\n        for (let h=0; h<H.length; h++) H[h] = ('00000000'+H[h].toString(16)).slice(-8);\n\n        // concatenate H0..H4, with separator if required\n        const separator = opt.outFormat=='hex-w' ? ' ' : '';\n\n        return H.join(separator);\n\n        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n        function utf8Encode(str) {\n            try {\n                return new TextEncoder().encode(str, 'utf-8').reduce((prev, curr) => prev + String.fromCharCode(curr), '');\n            } catch (e) { // no TextEncoder available?\n                return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n            }\n        }\n\n        function hexBytesToString(hexStr) { // convert string of hex numbers to a string of chars (eg '616263' -> 'abc').\n            const str = hexStr.replace(' ', ''); // allow space-separated groups\n            return str=='' ? '' : str.match(/.{2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join('');\n        }\n    }\n\n\n    /**\n     * Function 'f' [4.1.1].\n     * @private\n     */\n    static f(s, x, y, z)  {\n        switch (s) {\n            case 0: return (x & y) ^ (~x & z);          // Ch()\n            case 1: return  x ^ y  ^  z;                // Parity()\n            case 2: return (x & y) ^ (x & z) ^ (y & z); // Maj()\n            case 3: return  x ^ y  ^  z;                // Parity()\n        }\n    }\n\n\n    /**\n     * Rotates left (circular left shift) value x by n positions [3.2.5].\n     * @private\n     */\n    static ROTL(x, n) {\n        return (x<<n) | (x>>>(32-n));\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Sha1;\n","/* eslint-disable @typescript-eslint/camelcase */\n/* eslint-disable object-property-newline */\nimport { TDspMeta, TFaustCompileArgs } from \"./types\";\nimport mixer32DataURI from \"./wasm/mixer32.wasm\";\n\nexport const ab2str = (buf: ArrayBuffer): string => (buf ? String.fromCharCode.apply(null, new Uint8Array(buf)) : null);\nexport const str2ab = (str: string): ArrayBuffer => {\n    if (!str) return null;\n    const buf = new ArrayBuffer(str.length);\n    const bufView = new Uint8Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n};\nexport const atoUint6 = (nChr: number) => { // eslint-disable-line arrow-body-style\n    return nChr > 64 && nChr < 91\n        ? nChr - 65\n        : nChr > 96 && nChr < 123\n            ? nChr - 71\n            : nChr > 47 && nChr < 58\n                ? nChr + 4\n                : nChr === 43\n                    ? 62\n                    : nChr === 47\n                        ? 63\n                        : 0;\n};\nexport const atoab = (sBase64: string, nBlocksSize?: number) => {\n    if (typeof window.atob === \"function\") return str2ab(atob(sBase64));\n    const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\");\n    const nInLen = sB64Enc.length;\n    const nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2;\n    const taBytes = new Uint8Array(nOutLen);\n    for (let nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n        nMod4 = nInIdx & 3;\n        nUint24 |= atoUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;\n        if (nMod4 === 3 || nInLen - nInIdx === 1) {\n            for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n                taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n            }\n            nUint24 = 0;\n        }\n    }\n    return taBytes.buffer;\n};\nexport const heap2Str = (buf: number[]) => {\n    let str = \"\";\n    let i = 0;\n    while (buf[i] !== 0) {\n        str += String.fromCharCode(buf[i++]);\n    }\n    return str;\n};\nexport const mixer32Module = new WebAssembly.Module(atoab(mixer32DataURI.split(\",\")[1]));\nexport const midiToFreq = (note: number) => 440.0 * 2 ** ((note - 69) / 12);\nexport const remap = (v: number, mn0: number, mx0: number, mn1: number, mx1: number) => (v - mn0) / (mx0 - mn0) * (mx1 - mn1) + mn1;\nexport const findPath = (o: any, p: string) => {\n    if (typeof o !== \"object\") return false;\n    if (o.address) {\n        return (o.address === p);\n    }\n    for (const k in o) {\n        if (findPath(o[k], p)) return true;\n    }\n    return false;\n};\nexport const findPathClosure = () => {\n    const findPath = (o: any, p: string) => {\n        if (typeof o !== \"object\") return false;\n        if (o.address) {\n            return (o.address === p);\n        }\n        for (const k in o) {\n            if (findPath(o[k], p)) return true;\n        }\n        return false;\n    };\n    return findPath;\n};\nexport const createWasmImport = (voices: number, memory: WebAssembly.Memory) => ({\n    env: {\n        memory: voices ? memory : undefined, memoryBase: 0, tableBase: 0,\n        _abs: Math.abs,\n        // Float version\n        _acosf: Math.acos, _asinf: Math.asin, _atanf: Math.atan, _atan2f: Math.atan2,\n        _ceilf: Math.ceil, _cosf: Math.cos, _expf: Math.exp, _floorf: Math.floor,\n        _fmodf: (x: number, y: number) => x % y,\n        _logf: Math.log, _log10f: Math.log10, _max_f: Math.max, _min_f: Math.min,\n        _remainderf: (x: number, y: number) => x - Math.round(x / y) * y,\n        _powf: Math.pow, _roundf: Math.fround, _sinf: Math.sin, _sqrtf: Math.sqrt, _tanf: Math.tan,\n        _acoshf: Math.acosh, _asinhf: Math.asinh, _atanhf: Math.atanh,\n        _coshf: Math.cosh, _sinhf: Math.sinh, _tanhf: Math.tanh,\n        // Double version\n        _acos: Math.acos, _asin: Math.asin, _atan: Math.atan, _atan2: Math.atan2,\n        _ceil: Math.ceil, _cos: Math.cos, _exp: Math.exp, _floor: Math.floor,\n        _fmod: (x: number, y: number) => x % y,\n        _log: Math.log, _log10: Math.log10, _max_: Math.max, _min_: Math.min,\n        _remainder: (x: number, y: number) => x - Math.round(x / y) * y,\n        _pow: Math.pow, _round: Math.fround, _sin: Math.sin, _sqrt: Math.sqrt, _tan: Math.tan,\n        _acosh: Math.acosh, _asinh: Math.asinh, _atanh: Math.atanh,\n        _cosh: Math.cosh, _sinh: Math.sinh, _tanh: Math.tanh,\n        table: new WebAssembly.Table({ initial: 0, element: \"anyfunc\" })\n    }\n});\nexport const createWasmMemory = (voicesIn: number, dspMeta: TDspMeta, effectMeta: TDspMeta, bufferSize: number) => {\n    // Hack : at least 4 voices (to avoid weird wasm memory bug?)\n    const voices = Math.max(4, voicesIn);\n    // Memory allocator\n    const ptrSize = 4;\n    const sampleSize = 4;\n    const pow2limit = (x: number) => {\n        let n = 65536; // Minimum = 64 kB\n        while (n < x) { n *= 2; }\n        return n;\n    };\n    const effectSize = effectMeta ? effectMeta.size : 0;\n    let memorySize = pow2limit(\n        effectSize\n        + dspMeta.size * voices\n        + (dspMeta.inputs + dspMeta.outputs * 2)\n        * (ptrSize + bufferSize * sampleSize)\n    ) / 65536;\n    memorySize = Math.max(2, memorySize); // As least 2\n    return new WebAssembly.Memory({ initial: memorySize, maximum: memorySize });\n};\n\nexport const args2String = (args: TFaustCompileArgs) => {\n    let argStr = \"\";\n    for (const key in args) {\n        const arg = args[key];\n        if (Array.isArray(arg)) arg.forEach((s: string) => argStr += key + \" \" + s + \" \");\n        else argStr += key + \" \" + arg + \" \";\n    }\n    return argStr;\n};\n\nexport const argsTbl2String = (args: string[]) => {\n    let argStr = \"\";\n    args.forEach( (item) => { argStr += item + \" \"} );\n    return argStr;\n};\n\nexport const toArgv = (args: TFaustCompileArgs) => {\n    const argv: string[] = [];\n    for (const key in args) {\n        const arg = args[key];\n        if (Array.isArray(arg)) arg.forEach((s: string) => argv.push(key, s));\n        else if (typeof arg === \"number\") argv.push(key, arg.toString());\n        else argv.push(key, arg);\n    }\n    return argv;\n};\n","export default \"data:application/wasm;base64,AGFzbQEAAAABj4CAgAACYAN/f38AYAR/f39/AX0CkoCAgAABBm1lbW9yeQZtZW1vcnkCAAIDg4CAgAACAAEHmoCAgAACC2NsZWFyT3V0cHV0AAAIbWl4Vm9pY2UAAQqKgoCAAALigICAAAEDfwJAQQAhBQNAAkAgAiAFQQJ0aigCACEDQQAhBANAAkAgAyAEQQJ0akMAAAAAOAIAIARBAWohBCAEIABIBEAMAgUMAQsACwsgBUEBaiEFIAUgAUgEQAwCBQwBCwALCwsLnYGAgAACBH8DfQJ9QQAhB0MAAAAAIQgDQAJAQQAhBiACIAdBAnRqKAIAIQQgAyAHQQJ0aigCACEFA0ACQCAEIAZBAnRqKgIAIQkgCCAJi5chCCAFIAZBAnRqKgIAIQogBSAGQQJ0aiAKIAmSOAIAIAZBAWohBiAGIABIBEAMAgUMAQsACwsgB0EBaiEHIAcgAUgEQAwCBQwBCwALCyAIDwsL\"","/* eslint-disable no-restricted-properties */\n/* eslint-disable @typescript-eslint/camelcase */\n/* eslint-disable object-property-newline */\n/* eslint-disable object-curly-newline */\nimport { Faust } from \"./Faust\";\nimport { mixer32Module, createWasmMemory, createWasmImport, midiToFreq, remap } from \"./utils\";\nimport { TCompiledDsp, FaustScriptProcessorNode, TAudioNodeOptions, FaustWebAssemblyMixerExports, FaustWebAssemblyExports } from \"./types\";\n\nexport class FaustWasmToScriptProcessor {\n    faust: Faust;\n    constructor(faust: Faust) {\n        this.faust = faust;\n    }\n    private initNode(compiledDsp: TCompiledDsp, dspInstance: WebAssembly.Instance, effectInstance: WebAssembly.Instance, mixerInstance: WebAssembly.Instance, audioCtx: AudioContext, bufferSize?: number, memory?: WebAssembly.Memory, voices?: number, plotHandler?: (plotted: Float32Array[], index: number, events?: { type: string; data: any }[]) => any) {\n        let node: FaustScriptProcessorNode;\n        const dspMeta = compiledDsp.dspMeta;\n        const inputs = dspMeta.inputs;\n        const outputs = dspMeta.outputs;\n        try {\n            node = audioCtx.createScriptProcessor(bufferSize, inputs, outputs) as FaustScriptProcessorNode;\n        } catch (e) {\n            this.faust.error(\"Error in createScriptProcessor: \" + e.message);\n            throw e;\n        }\n        node.destroyed = false;\n        node.voices = voices;\n        node.dspMeta = dspMeta;\n\n        node.outputHandler = null;\n        node.computeHandler = null;\n        node.$ins = null;\n        node.$outs = null;\n\n        node.dspInChannnels = [];\n        node.dspOutChannnels = [];\n\n        node.fPitchwheelLabel = [];\n        node.fCtrlLabel = new Array(128).fill(null).map(() => []);\n\n        node.numIn = inputs;\n        node.numOut = outputs;\n\n        this.faust.log(node.numIn);\n        this.faust.log(node.numOut);\n\n        // Memory allocator\n        node.ptrSize = 4;\n        node.sampleSize = 4;\n\n        node.factory = dspInstance.exports as FaustWebAssemblyExports;\n        node.HEAP = node.voices ? memory.buffer : node.factory.memory.buffer;\n        node.HEAP32 = new Int32Array(node.HEAP);\n        node.HEAPF32 = new Float32Array(node.HEAP);\n\n        this.faust.log(node.HEAP);\n        this.faust.log(node.HEAP32);\n        this.faust.log(node.HEAPF32);\n\n        // JSON is as offset 0\n        /*\n        var HEAPU8 = new Uint8Array(sp.HEAP);\n        console.log(this.Heap2Str(HEAPU8));\n        */\n        // bargraph\n        node.outputsTimer = 5;\n        node.outputsItems = [];\n\n        // input items\n        node.inputsItems = [];\n\n        // Start of HEAP index\n\n        // DSP is placed first with index 0. Audio buffer start at the end of DSP.\n        node.$audioHeap = node.voices ? 0 : node.dspMeta.size;\n\n        // Setup pointers offset\n        node.$$audioHeapInputs = node.$audioHeap;\n        node.$$audioHeapOutputs = node.$$audioHeapInputs + node.numIn * node.ptrSize;\n        if (node.voices) {\n            node.$$audioHeapMixing = node.$$audioHeapOutputs + node.numOut * node.ptrSize;\n            // Setup buffer offset\n            node.$audioHeapInputs = node.$$audioHeapMixing + node.numOut * node.ptrSize;\n            node.$audioHeapOutputs = node.$audioHeapInputs + node.numIn * node.bufferSize * node.sampleSize;\n            node.$audioHeapMixing = node.$audioHeapOutputs + node.numOut * node.bufferSize * node.sampleSize;\n            node.$dsp = node.$audioHeapMixing + node.numOut * node.bufferSize * node.sampleSize;\n        } else {\n            node.$audioHeapInputs = node.$$audioHeapOutputs + node.numOut * node.ptrSize;\n            node.$audioHeapOutputs = node.$audioHeapInputs + node.numIn * node.bufferSize * node.sampleSize;\n            // Start of DSP memory : Mono DSP is placed first with index 0\n            node.$dsp = 0;\n        }\n\n        if (node.voices) {\n            node.effectMeta = compiledDsp.effectMeta;\n            node.$mixing = null;\n            node.fFreqLabel$ = [];\n            node.fGateLabel$ = [];\n            node.fGainLabel$ = [];\n            node.fDate = 0;\n\n            node.mixer = mixerInstance.exports as FaustWebAssemblyMixerExports;\n            node.effect = effectInstance ? effectInstance.exports as FaustWebAssemblyExports : null;\n            this.faust.log(node.mixer);\n            this.faust.log(node.factory);\n            this.faust.log(node.effect);\n            // Start of DSP memory ('polyphony' DSP voices)\n            node.dspVoices$ = [];\n            node.dspVoicesState = [];\n            node.dspVoicesLevel = [];\n            node.dspVoicesDate = [];\n\n            node.kActiveVoice = 0;\n            node.kFreeVoice = -1;\n            node.kReleaseVoice = -2;\n            node.kNoVoice = -3;\n\n            for (let i = 0; i < node.voices; i++) {\n                node.dspVoices$[i] = node.$dsp + i * node.dspMeta.size;\n                node.dspVoicesState[i] = node.kFreeVoice;\n                node.dspVoicesLevel[i] = 0;\n                node.dspVoicesDate[i] = 0;\n            }\n            // Effect memory starts after last voice\n            node.$effect = node.dspVoices$[node.voices - 1] + node.dspMeta.size;\n        }\n\n        node.pathTable$ = {};\n\n        node.$buffer = 0;\n        node.cachedEvents = [];\n        node.plotHandler = plotHandler;\n\n        node.updateOutputs = () => {\n            if (node.outputsItems.length > 0 && node.outputHandler && node.outputsTimer-- === 0) {\n                node.outputsTimer = 5;\n                node.outputsItems.forEach(item => node.outputHandler(item, node.factory.getParamValue(node.$dsp, node.pathTable$[item])));\n            }\n        };\n\n        // JSON parsing\n        node.parseUI = ui => ui.forEach(group => node.parseGroup(group));\n        node.parseGroup = group => (group.items ? node.parseItems(group.items) : null);\n        node.parseItems = items => items.forEach(item => node.parseItem(item));\n        node.parseItem = (item) => {\n            if (item.type === \"vgroup\" || item.type === \"hgroup\" || item.type === \"tgroup\") {\n                node.parseItems(item.items);\n            } else if (item.type === \"hbargraph\" || item.type === \"vbargraph\") {\n                // Keep bargraph adresses\n                node.outputsItems.push(item.address);\n                node.pathTable$[item.address] = item.index;\n            } else if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"button\" || item.type === \"checkbox\" || item.type === \"nentry\") {\n                // Keep inputs adresses\n                node.inputsItems.push(item.address);\n                node.pathTable$[item.address] = item.index;\n                if (!item.meta) return;\n                item.meta.forEach((meta) => {\n                    const { midi } = meta;\n                    if (!midi) return;\n                    const strMidi = midi.trim();\n                    if (strMidi === \"pitchwheel\") {\n                        node.fPitchwheelLabel.push({ path: item.address, min: item.min, max: item.max });\n                    } else {\n                        const matched = strMidi.match(/^ctrl\\s(\\d+)/);\n                        if (!matched) return;\n                        node.fCtrlLabel[parseInt(matched[1])].push({ path: item.address, min: item.min, max: item.max });\n                    }\n                });\n            }\n        };\n\n        if (node.voices) {\n            node.getPlayingVoice = (pitch) => {\n                let voice = node.kNoVoice;\n                let oldestDatePlaying = Number.MAX_VALUE;\n                for (let i = 0; i < node.voices; i++) {\n                    if (node.dspVoicesState[i] === pitch) {\n                        // Keeps oldest playing voice\n                        if (node.dspVoicesDate[i] < oldestDatePlaying) {\n                            oldestDatePlaying = node.dspVoicesDate[i];\n                            voice = i;\n                        }\n                    }\n                }\n                return voice;\n            };\n            // Always returns a voice\n            node.allocVoice = (voice) => {\n                // so that envelop is always re-initialized\n                node.factory.instanceClear(node.dspVoices$[voice]);\n                node.dspVoicesDate[voice] = node.fDate++;\n                node.dspVoicesState[voice] = node.kActiveVoice;\n                return voice;\n            };\n            node.getFreeVoice = () => {\n                for (let i = 0; i < node.voices; i++) {\n                    if (node.dspVoicesState[i] === node.kFreeVoice) return node.allocVoice(i);\n                }\n                let voiceRelease = node.kNoVoice;\n                let voicePlaying = node.kNoVoice;\n                let oldestDateRelease = Number.MAX_VALUE;\n                let oldestDatePlaying = Number.MAX_VALUE;\n                for (let i = 0; i < node.voices; i++) { // Scan all voices\n                    // Try to steal a voice in kReleaseVoice mode...\n                    if (node.dspVoicesState[i] === node.kReleaseVoice) {\n                        // Keeps oldest release voice\n                        if (node.dspVoicesDate[i] < oldestDateRelease) {\n                            oldestDateRelease = node.dspVoicesDate[i];\n                            voiceRelease = i;\n                        }\n                    } else if (node.dspVoicesDate[i] < oldestDatePlaying) {\n                        oldestDatePlaying = node.dspVoicesDate[i];\n                        voicePlaying = i;\n                    }\n                }\n                // Then decide which one to steal\n                if (oldestDateRelease !== Number.MAX_VALUE) {\n                    this.faust.log(`Steal release voice : voice_date = ${node.dspVoicesDate[voiceRelease]} cur_date = ${node.fDate} voice = ${voiceRelease}`);\n                    return node.allocVoice(voiceRelease);\n                }\n                if (oldestDatePlaying !== Number.MAX_VALUE) {\n                    this.faust.log(`Steal playing voice : voice_date = ${node.dspVoicesDate[voicePlaying]} cur_date = ${node.fDate} voice = ${voicePlaying}`);\n                    return node.allocVoice(voicePlaying);\n                }\n                return node.kNoVoice;\n            };\n            node.keyOn = (channel, pitch, velocity) => {\n                node.cachedEvents.push({ type: \"keyOn\", data: [channel, pitch, velocity] });\n                const voice = node.getFreeVoice();\n                this.faust.log(\"keyOn voice \" + voice);\n                node.fFreqLabel$.forEach($ => node.factory.setParamValue(node.dspVoices$[voice], $, midiToFreq(pitch)));\n                node.fGateLabel$.forEach($ => node.factory.setParamValue(node.dspVoices$[voice], $, 1));\n                node.fGainLabel$.forEach($ => node.factory.setParamValue(node.dspVoices$[voice], $, velocity / 127));\n                node.dspVoicesState[voice] = pitch;\n            };\n            node.keyOff = (channel, pitch, velocity) => { // eslint-disable-line @typescript-eslint/no-unused-vars\n                node.cachedEvents.push({ type: \"keyOff\", data: [channel, pitch, velocity] });\n                const voice = node.getPlayingVoice(pitch);\n                if (voice === node.kNoVoice) return this.faust.log(\"Playing voice not found...\");\n                node.fGateLabel$.forEach($ => node.factory.setParamValue(node.dspVoices$[voice], $, 0)); // No use of velocity for now...\n                node.dspVoicesState[voice] = node.kReleaseVoice; // Release voice\n                return this.faust.log(\"keyOff voice \" + voice);\n            };\n            node.allNotesOff = () => {\n                node.cachedEvents.push({ type: \"ctrlChange\", data: [0, 123, 0] });\n                for (let i = 0; i < node.voices; i++) {\n                    node.fGateLabel$.forEach($gate => node.factory.setParamValue(node.dspVoices$[i], $gate, 0));\n                    node.dspVoicesState[i] = node.kReleaseVoice;\n                }\n            };\n        }\n        node.midiMessage = (data) => {\n            node.cachedEvents.push({ data, type: \"midi\" });\n            const cmd = data[0] >> 4;\n            const channel = data[0] & 0xf;\n            const data1 = data[1];\n            const data2 = data[2];\n            if (channel === 9) return undefined;\n            if (node.voices) {\n                if (cmd === 8 || (cmd === 9 && data2 === 0)) return node.keyOff(channel, data1, data2);\n                if (cmd === 9) return node.keyOn(channel, data1, data2);\n            }\n            if (cmd === 11) return node.ctrlChange(channel, data1, data2);\n            if (cmd === 14) return node.pitchWheel(channel, (data2 * 128.0 + data1));\n            return undefined;\n        };\n        node.ctrlChange = (channel, ctrl, value) => {\n            node.cachedEvents.push({ type: \"ctrlChange\", data: [channel, ctrl, value] });\n            if (!node.fCtrlLabel[ctrl].length) return;\n            node.fCtrlLabel[ctrl].forEach((ctrl) => {\n                const { path } = ctrl;\n                node.setParamValue(path, remap(value, 0, 127, ctrl.min, ctrl.max));\n                if (node.outputHandler) node.outputHandler(path, node.getParamValue(path));\n            });\n        };\n        node.pitchWheel = (channel, wheel) => {\n            node.cachedEvents.push({ type: \"pitchWheel\", data: [channel, wheel] });\n            node.fPitchwheelLabel.forEach((pw) => {\n                node.setParamValue(pw.path, remap(wheel, 0, 16383, pw.min, pw.max));\n                if (node.outputHandler) node.outputHandler(pw.path, node.getParamValue(pw.path));\n            });\n        };\n        node.compute = (e) => {\n            if (node.destroyed) return false;\n            for (let i = 0; i < node.numIn; i++) { // Read inputs\n                const input = e.inputBuffer.getChannelData(i);\n                const dspInput = node.dspInChannnels[i];\n                dspInput.set(input);\n            }\n            // Possibly call an externally given callback (for instance to synchronize playing a MIDIFile...)\n            if (node.computeHandler) node.computeHandler(node.bufferSize);\n            if (node.voices) {\n                node.mixer.clearOutput(node.bufferSize, node.numOut, node.$outs); // First clear the outputs\n                for (let i = 0; i < node.voices; i++) { // Compute all running voices\n                    node.factory.compute(node.dspVoices$[i], node.bufferSize, node.$ins, node.$mixing); // Compute voice\n                    node.mixer.mixVoice(node.bufferSize, node.numOut, node.$mixing, node.$outs); // Mix it in result\n                }\n                if (node.effect) node.effect.compute(node.$effect, node.bufferSize, node.$outs, node.$outs); // Apply effect. Not a typo, effect is applied on the outs.\n            } else {\n                node.factory.compute(node.$dsp, node.bufferSize, node.$ins, node.$outs); // Compute\n            }\n            node.updateOutputs(); // Update bargraph\n            const outputs = new Array(node.numOut).fill(null).map(() => new Float32Array(node.bufferSize));\n            for (let i = 0; i < node.numOut; i++) { // Write outputs\n                const output = e.outputBuffer.getChannelData(i);\n                const dspOutput = node.dspOutChannnels[i];\n                output.set(dspOutput);\n                outputs[i].set(dspOutput);\n            }\n            if (node.plotHandler) node.plotHandler(outputs, node.$buffer++, node.cachedEvents.length ? node.cachedEvents : undefined);\n            node.cachedEvents = [];\n            return true;\n        };\n        node.setup = () => { // Setup web audio context\n            this.faust.log(\"buffer_size \" + node.bufferSize);\n            node.onaudioprocess = node.compute;\n            if (node.numIn > 0) {\n                node.$ins = node.$$audioHeapInputs;\n                for (let i = 0; i < node.numIn; i++) {\n                    node.HEAP32[(node.$ins >> 2) + i] = node.$audioHeapInputs + node.bufferSize * node.sampleSize * i;\n                }\n                // Prepare Ins buffer tables\n                const dspInChans = node.HEAP32.subarray(node.$ins >> 2, (node.$ins + node.numIn * node.ptrSize) >> 2);\n                for (let i = 0; i < node.numIn; i++) {\n                    node.dspInChannnels[i] = node.HEAPF32.subarray(dspInChans[i] >> 2, (dspInChans[i] + node.bufferSize * node.sampleSize) >> 2);\n                }\n            }\n            if (node.numOut > 0) {\n                node.$outs = node.$$audioHeapOutputs;\n                if (node.voices) node.$mixing = node.$$audioHeapMixing;\n                for (let i = 0; i < node.numOut; i++) {\n                    node.HEAP32[(node.$outs >> 2) + i] = node.$audioHeapOutputs + node.bufferSize * node.sampleSize * i;\n                    if (node.voices) node.HEAP32[(node.$mixing >> 2) + i] = node.$audioHeapMixing + node.bufferSize * node.sampleSize * i;\n                }\n                // Prepare Out buffer tables\n                const dspOutChans = node.HEAP32.subarray(node.$outs >> 2, (node.$outs + node.numOut * node.ptrSize) >> 2);\n                for (let i = 0; i < node.numOut; i++) {\n                    node.dspOutChannnels[i] = node.HEAPF32.subarray(dspOutChans[i] >> 2, (dspOutChans[i] + node.bufferSize * node.sampleSize) >> 2);\n                }\n            }\n            // Parse JSON UI part\n            node.parseUI(node.dspMeta.ui);\n            if (node.effect) node.parseUI(node.effectMeta.ui);\n\n            // keep 'keyOn/keyOff' labels\n            if (node.voices) {\n                node.inputsItems.forEach((item) => {\n                    if (item.endsWith(\"/gate\")) node.fGateLabel$.push(node.pathTable$[item]);\n                    else if (item.endsWith(\"/freq\")) node.fFreqLabel$.push(node.pathTable$[item]);\n                    else if (item.endsWith(\"/gain\")) node.fGainLabel$.push(node.pathTable$[item]);\n                });\n                // Init DSP voices\n                node.dspVoices$.forEach($voice => node.factory.init($voice, audioCtx.sampleRate));\n                // Init effect\n                if (node.effect) node.effect.init(node.$effect, audioCtx.sampleRate);\n            } else {\n                // Init DSP\n                node.factory.init(node.$dsp, audioCtx.sampleRate);\n            }\n        };\n        node.getSampleRate = () => audioCtx.sampleRate;\n        node.getNumInputs = () => node.numIn;\n        node.getNumOutputs = () => node.numOut;\n        node.init = (sampleRate) => {\n            if (node.voices) node.dspVoices$.forEach($voice => node.factory.init($voice, sampleRate));\n            else node.factory.init(node.$dsp, sampleRate);\n        };\n        node.instanceInit = (sampleRate) => {\n            if (node.voices) node.dspVoices$.forEach($voice => node.factory.instanceInit($voice, sampleRate));\n            else node.factory.instanceInit(node.$dsp, sampleRate);\n        };\n        node.instanceConstants = (sampleRate) => {\n            if (node.voices) node.dspVoices$.forEach($voice => node.factory.instanceConstants($voice, sampleRate));\n            else node.factory.instanceConstants(node.$dsp, sampleRate);\n        };\n        node.instanceResetUserInterface = () => {\n            if (node.voices) node.dspVoices$.forEach($voice => node.factory.instanceResetUserInterface($voice));\n            else node.factory.instanceResetUserInterface(node.$dsp);\n        };\n        node.instanceClear = () => {\n            if (node.voices) node.dspVoices$.forEach($voice => node.factory.instanceClear($voice));\n            else node.factory.instanceClear(node.$dsp);\n        };\n        node.metadata = handler => (node.dspMeta.meta ? node.dspMeta.meta.forEach(meta => handler.declare(Object.keys(meta)[0], meta[Object.keys(meta)[0]])) : undefined);\n        node.setOutputParamHandler = handler => node.outputHandler = handler;\n        node.getOutputParamHandler = () => node.outputHandler;\n        node.setComputeHandler = handler => node.computeHandler = handler;\n        node.getComputeHandler = () => node.computeHandler;\n        const findPath = (o: any, p: string) => {\n            if (typeof o !== \"object\") return false;\n            if (o.address) {\n                if (o.address === p) return true;\n                return false;\n            }\n            for (const k in o) {\n                if (findPath(o[k], p)) return true;\n            }\n            return false;\n        };\n        node.setParamValue = (path, value) => {\n            node.cachedEvents.push({ type: \"param\", data: { path, value } });\n            if (node.voices) {\n                if (node.effect && findPath(node.effectMeta.ui, path)) node.effect.setParamValue(node.$effect, node.pathTable$[path], value);\n                else node.dspVoices$.forEach($voice => node.factory.setParamValue($voice, node.pathTable$[path], value));\n            } else {\n                node.factory.setParamValue(node.$dsp, node.pathTable$[path], value);\n            }\n        };\n        node.getParamValue = (path) => {\n            if (node.voices) {\n                if (node.effect && findPath(node.effectMeta.ui, path)) return node.effect.getParamValue(node.$effect, node.pathTable$[path]);\n                return node.factory.getParamValue(node.dspVoices$[0], node.pathTable$[path]);\n            }\n            return node.factory.getParamValue(node.$dsp, node.pathTable$[path]);\n        };\n        node.getParams = () => node.inputsItems;\n        node.getJSON = () => {\n            if (node.voices) {\n                const o = node.dspMeta;\n                const e = node.effectMeta;\n                const r = { ...o };\n                if (e) {\n                    r.ui = [{ type: \"tgroup\", label: \"Sequencer\", items: [\n                        { type: \"vgroup\", label: \"Instrument\", items: o.ui },\n                        { type: \"vgroup\", label: \"Effect\", items: e.ui }\n                    ] }];\n                } else {\n                    r.ui = [{ type: \"tgroup\", label: \"Polyphonic\", items: [\n                        { type: \"vgroup\", label: \"Voices\", items: o.ui }\n                    ] }];\n                }\n                return JSON.stringify(r);\n            }\n            return JSON.stringify(node.dspMeta);\n        };\n        node.getUI = () => {\n            if (node.voices) {\n                const o = node.dspMeta;\n                const e = node.effectMeta;\n                if (e) {\n                    return [{ type: \"tgroup\", label: \"Sequencer\", items: [\n                        { type: \"vgroup\", label: \"Instrument\", items: o.ui },\n                        { type: \"vgroup\", label: \"Effect\", items: e.ui }\n                    ] }];\n                }\n                return [{ type: \"tgroup\", label: \"Polyphonic\", items: [\n                    { type: \"vgroup\", label: \"Voices\", items: o.ui }\n                ] }];\n            }\n            return node.dspMeta.ui;\n        };\n        node.destroy = () => {\n            node.destroyed = true;\n            delete node.outputHandler;\n            delete node.computeHandler;\n            delete node.plotHandler;\n        };\n        // Init resulting DSP\n        node.setup();\n        return node;\n    }\n    /**\n     * Create a ScriptProcessorNode Web Audio object\n     * by loading and compiling the Faust wasm file\n     *\n     * @param {TAudioNodeOptions} optionsIn\n     * @returns {Promise<FaustScriptProcessorNode>} a Promise for valid WebAudio ScriptProcessorNode object or null\n     */\n    async getNode(optionsIn: TAudioNodeOptions): Promise<FaustScriptProcessorNode> {\n        const { compiledDsp, audioCtx, bufferSize: bufferSizeIn, voices, plotHandler } = optionsIn;\n        const bufferSize = bufferSizeIn || 512;\n        let node: FaustScriptProcessorNode;\n        try {\n            let effectInstance: WebAssembly.Instance;\n            let mixerInstance: WebAssembly.Instance;\n            const memory = createWasmMemory(voices, compiledDsp.dspMeta, compiledDsp.effectMeta, bufferSize);\n            const importObject = createWasmImport(voices, memory);\n            if (voices) {\n                const mixerObject = { imports: { print: console.log }, memory: { memory } }; // eslint-disable-line no-console\n                mixerInstance = new WebAssembly.Instance(mixer32Module, mixerObject);\n                try {\n                    effectInstance = await WebAssembly.instantiate(compiledDsp.effectModule, importObject);\n                } catch (e) {} // eslint-disable-line no-empty\n            }\n            const dspInstance = await WebAssembly.instantiate(compiledDsp.dspModule, importObject);\n            node = this.initNode(compiledDsp, dspInstance, effectInstance, mixerInstance, audioCtx, bufferSize, memory, voices, plotHandler);\n        } catch (e) {\n            this.faust.error(\"Faust \" + compiledDsp.shaKey + \" cannot be loaded or compiled\");\n            throw e;\n        }\n        return node;\n    }\n}\n","/* eslint-disable no-console */\n/* eslint-disable no-restricted-properties */\n/* eslint-disable @typescript-eslint/camelcase */\n/* eslint-disable object-property-newline */\n/* eslint-env worker */\nimport { TDspMeta, FaustDspNode, TFaustUI, TFaustUIGroup, TFaustUIItem, FaustWebAssemblyExports, FaustWebAssemblyMixerExports, TCompiledDsp } from \"./types\";\n\n// AudioWorklet Globals\ndeclare class AudioWorkletProcessor {\n    public port: MessagePort;\n    public process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: { [key: string]: Float32Array }): boolean;\n    constructor(options: AudioWorkletNodeOptions);\n}\ntype AudioWorkletProcessorConstructor<T extends AudioWorkletProcessor> = {\n    new (options: AudioWorkletNodeOptions): T;\n};\ndeclare function registerProcessor<T extends AudioWorkletProcessor>(name: string, constructor: AudioWorkletProcessorConstructor<T>): void;\ndeclare const currentFrame: number;\ndeclare const currentTime: number;\ndeclare const sampleRate: number;\ninterface AudioParamDescriptor {\n    automationRate?: AutomationRate;\n    defaultValue?: number;\n    maxValue?: number;\n    minValue?: number;\n    name: string;\n}\n\n// Injected by Faust\ntype FaustData = {\n    id: string;\n    voices: number;\n    dspMeta: TDspMeta;\n    effectMeta?: TDspMeta;\n};\ndeclare const faustData: FaustData;\n\ndeclare const remap: (v: number, mn0: number, mx0: number, mn1: number, mx1: number) => number;\ndeclare const midiToFreq: (v: number) => number;\ndeclare const findPath: (o: any, p: string) => boolean;\ndeclare const createWasmImport: (voices: number, memory: WebAssembly.Memory) => { [key: string]: any };\ndeclare const createWasmMemory: (voicesIn: number, dspMeta: TDspMeta, effectMeta: TDspMeta, bufferSize: number) => WebAssembly.Memory;\n\nexport const FaustAudioWorkletProcessorWrapper = () => {\n    class FaustConst {\n        static id = faustData.id;\n        static dspMeta = faustData.dspMeta;\n        static effectMeta = faustData.effectMeta;\n    }\n    class FaustAudioWorkletProcessor extends AudioWorkletProcessor implements FaustDspNode {\n        static bufferSize = 128;\n        // JSON parsing functions\n        static parseUI(ui: TFaustUI, obj: AudioParamDescriptor[] | FaustAudioWorkletProcessor, callback: (...args: any[]) => any) {\n            for (let i = 0; i < ui.length; i++) {\n                this.parseGroup(ui[i], obj, callback);\n            }\n        }\n        static parseGroup(group: TFaustUIGroup, obj: AudioParamDescriptor[] | FaustAudioWorkletProcessor, callback: (...args: any[]) => any) {\n            if (group.items) {\n                this.parseItems(group.items, obj, callback);\n            }\n        }\n        static parseItems(items: TFaustUIItem[], obj: AudioParamDescriptor[] | FaustAudioWorkletProcessor, callback: (...args: any[]) => any) {\n            for (let i = 0; i < items.length; i++) {\n                callback(items[i], obj, callback);\n            }\n        }\n        static parseItem(item: TFaustUIItem, obj: AudioParamDescriptor[], callback: (...args: any[]) => any) {\n            if (item.type === \"vgroup\" || item.type === \"hgroup\" || item.type === \"tgroup\") {\n                FaustAudioWorkletProcessor.parseItems(item.items, obj, callback); // callback may not binded to this\n            } else if (item.type === \"hbargraph\" || item.type === \"vbargraph\") {\n                // Nothing\n            } else if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"nentry\") {\n                if (!faustData.voices || (!item.address.endsWith(\"/gate\") && !item.address.endsWith(\"/freq\") && !item.address.endsWith(\"/gain\"))) {\n                    obj.push({ name: item.address, defaultValue: item.init || 0, minValue: item.min || 0, maxValue: item.max || 0 });\n                }\n            } else if (item.type === \"button\" || item.type === \"checkbox\") {\n                if (!faustData.voices || (!item.address.endsWith(\"/gate\") && !item.address.endsWith(\"/freq\") && !item.address.endsWith(\"/gain\"))) {\n                    obj.push({ name: item.address, defaultValue: item.init || 0, minValue: 0, maxValue: 1 });\n                }\n            }\n        }\n        static parseItem2(item: TFaustUIItem, obj: FaustAudioWorkletProcessor, callback: (...args: any[]) => any) {\n            if (item.type === \"vgroup\" || item.type === \"hgroup\" || item.type === \"tgroup\") {\n                FaustAudioWorkletProcessor.parseItems(item.items, obj, callback); // callback may not binded to this\n            } else if (item.type === \"hbargraph\" || item.type === \"vbargraph\") {\n                // Keep bargraph adresses\n                obj.outputsItems.push(item.address);\n                obj.pathTable$[item.address] = item.index;\n            } else if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"button\" || item.type === \"checkbox\" || item.type === \"nentry\") {\n                // Keep inputs adresses\n                obj.inputsItems.push(item.address);\n                obj.pathTable$[item.address] = item.index;\n                if (!item.meta) return;\n                item.meta.forEach((meta) => {\n                    const { midi } = meta;\n                    if (!midi) return;\n                    const strMidi = midi.trim();\n                    if (strMidi === \"pitchwheel\") {\n                        obj.fPitchwheelLabel.push({ path: item.address, min: item.min, max: item.max });\n                    } else {\n                        const matched = strMidi.match(/^ctrl\\s(\\d+)/);\n                        if (!matched) return;\n                        obj.fCtrlLabel[parseInt(matched[1])].push({ path: item.address, min: item.min, max: item.max });\n                    }\n                });\n            }\n        }\n        static get parameterDescriptors() {\n            // Analyse JSON to generate AudioParam parameters\n            const params = [] as AudioParamDescriptor[];\n            this.parseUI(FaustConst.dspMeta.ui, params, this.parseItem);\n            if (FaustConst.effectMeta) this.parseUI(FaustConst.effectMeta.ui, params, this.parseItem);\n            return params;\n        }\n        destroyed: boolean;\n        dspInstance: WebAssembly.Instance;\n        effectInstance?: WebAssembly.Instance;\n        mixerInstance?: WebAssembly.Instance;\n        memory?: WebAssembly.Memory;\n\n        bufferSize: number;\n        voices: number;\n        dspMeta: TDspMeta;\n        $ins: number;\n        $outs: number;\n        dspInChannnels: Float32Array[];\n        dspOutChannnels: Float32Array[];\n        fPitchwheelLabel: { path: string; min: number; max: number }[];\n        fCtrlLabel: { path: string; min: number; max: number }[][];\n        numIn: number;\n        numOut: number;\n        ptrSize: number;\n        sampleSize: number;\n        outputsTimer: number;\n        inputsItems: string[];\n        outputsItems: string[];\n        pathTable$: { [address: string]: number };\n        $audioHeap: number;\n        $$audioHeapInputs: number;\n        $$audioHeapOutputs: number;\n        $audioHeapInputs: number;\n        $audioHeapOutputs: number;\n        $dsp: number;\n        factory: FaustWebAssemblyExports;\n        HEAP: ArrayBuffer;\n        HEAP32: Int32Array;\n        HEAPF32: Float32Array;\n\n        effectMeta?: TDspMeta;\n        $effect?: number;\n        $mixing?: number;\n        fFreqLabel$?: number[];\n        fGateLabel$?: number[];\n        fGainLabel$?: number[];\n        fDate?: number;\n        $$audioHeapMixing?: number;\n        $audioHeapMixing?: number;\n        mixer?: FaustWebAssemblyMixerExports;\n        effect?: FaustWebAssemblyExports;\n        dspVoices$?: number[];\n        dspVoicesState?: number[];\n        dspVoicesLevel?: number[];\n        dspVoicesDate?: number[];\n        kActiveVoice?: number;\n        kFreeVoice?: number;\n        kReleaseVoice?: number;\n        kNoVoice?: number;\n\n        $buffer: number;\n        cachedEvents: { type: string; data: any }[];\n\n        outputHandler: (address: string, value: number) => any;\n        computeHandler: (bufferSize: number) => any;\n\n        handleMessage = (e: MessageEvent) => { // use arrow function for binding\n            const msg = e.data;\n            this.cachedEvents.push({ type: e.data.type, data: e.data.data });\n            switch (msg.type) {\n                // Generic MIDI message\n                case \"midi\": this.midiMessage(msg.data); break;\n                // Typed MIDI message\n                case \"keyOn\": this.keyOn(msg.data[0], msg.data[1], msg.data[2]); break;\n                case \"keyOff\": this.keyOff(msg.data[0], msg.data[1], msg.data[2]); break;\n                case \"ctrlChange\": this.ctrlChange(msg.data[0], msg.data[1], msg.data[2]); break;\n                case \"pitchWheel\": this.pitchWheel(msg.data[0], msg.data[1]); break;\n                // Generic data message\n                case \"param\": this.setParamValue(msg.data.path, msg.data.value); break;\n                // case \"patch\": this.onpatch(msg.data); break;\n                case \"destroy\": {\n                    this.port.close();\n                    this.destroyed = true;\n                    delete this.outputHandler;\n                    delete this.computeHandler;\n                    break;\n                }\n                default:\n            }\n        }\n        constructor(options: AudioWorkletNodeOptions) {\n            super(options);\n            const processorOptions: { id: string; voices: number; compiledDsp: TCompiledDsp; mixer32Module: WebAssembly.Module } = options.processorOptions;\n            this.instantiateWasm(processorOptions);\n            this.port.onmessage = this.handleMessage; // Naturally binded with arrow function property\n            this.destroyed = false;\n\n            this.bufferSize = 128;\n            this.voices = processorOptions.voices;\n            this.dspMeta = processorOptions.compiledDsp.dspMeta;\n\n            this.outputHandler = (path, value) => this.port.postMessage({ path, value, type: \"param\" });\n            this.computeHandler = null;\n\n            this.$ins = null;\n            this.$outs = null;\n\n            this.dspInChannnels = [];\n            this.dspOutChannnels = [];\n\n            this.fPitchwheelLabel = [];\n            this.fCtrlLabel = new Array(128).fill(null).map(() => []);\n\n            this.numIn = this.dspMeta.inputs;\n            this.numOut = this.dspMeta.outputs;\n\n            // Memory allocator\n            this.ptrSize = 4;\n            this.sampleSize = 4;\n\n            // Create the WASM instance\n            this.factory = this.dspInstance.exports as FaustWebAssemblyExports;\n            this.HEAP = this.voices ? this.memory.buffer : this.factory.memory.buffer;\n            this.HEAP32 = new Int32Array(this.HEAP);\n            this.HEAPF32 = new Float32Array(this.HEAP);\n\n            // console.log(this.HEAP);\n            // console.log(this.HEAP32);\n            // console.log(this.HEAPF32);\n\n            // bargraph\n            this.outputsTimer = 5;\n            this.outputsItems = [];\n\n            // input items\n            this.inputsItems = [];\n\n            // Start of HEAP index\n\n            // DSP is placed first with index 0. Audio buffer start at the end of DSP.\n            this.$audioHeap = this.voices ? 0 : this.dspMeta.size;\n\n            // Setup pointers offset\n            this.$$audioHeapInputs = this.$audioHeap;\n            this.$$audioHeapOutputs = this.$$audioHeapInputs + this.numIn * this.ptrSize;\n\n            // Setup buffer offset\n            this.$audioHeapInputs = this.$$audioHeapOutputs + (this.numOut * this.ptrSize);\n            this.$audioHeapOutputs = this.$audioHeapInputs + (this.numIn * this.bufferSize * this.sampleSize);\n            if (this.voices) {\n                this.$$audioHeapMixing = this.$$audioHeapOutputs + this.numOut * this.ptrSize;\n                // Setup buffer offset\n                this.$audioHeapInputs = this.$$audioHeapMixing + this.numOut * this.ptrSize;\n                this.$audioHeapOutputs = this.$audioHeapInputs + this.numIn * this.bufferSize * this.sampleSize;\n                this.$audioHeapMixing = this.$audioHeapOutputs + this.numOut * this.bufferSize * this.sampleSize;\n                this.$dsp = this.$audioHeapMixing + this.numOut * this.bufferSize * this.sampleSize;\n            } else {\n                this.$audioHeapInputs = this.$$audioHeapOutputs + this.numOut * this.ptrSize;\n                this.$audioHeapOutputs = this.$audioHeapInputs + this.numIn * this.bufferSize * this.sampleSize;\n                // Start of DSP memory : Mono DSP is placed first with index 0\n                this.$dsp = 0;\n            }\n\n            if (this.voices) {\n                this.effectMeta = FaustConst.effectMeta;\n                this.$mixing = null;\n                this.fFreqLabel$ = [];\n                this.fGateLabel$ = [];\n                this.fGainLabel$ = [];\n                this.fDate = 0;\n\n                this.mixer = this.mixerInstance.exports as FaustWebAssemblyMixerExports;\n                this.effect = this.effectInstance ? this.effectInstance.exports as FaustWebAssemblyExports : null;\n\n                // Start of DSP memory ('polyphony' DSP voices)\n                this.dspVoices$ = [];\n                this.dspVoicesState = [];\n                this.dspVoicesLevel = [];\n                this.dspVoicesDate = [];\n\n                this.kActiveVoice = 0;\n                this.kFreeVoice = -1;\n                this.kReleaseVoice = -2;\n                this.kNoVoice = -3;\n\n                for (let i = 0; i < this.voices; i++) {\n                    this.dspVoices$[i] = this.$dsp + i * this.dspMeta.size;\n                    this.dspVoicesState[i] = this.kFreeVoice;\n                    this.dspVoicesLevel[i] = 0;\n                    this.dspVoicesDate[i] = 0;\n                }\n                // Effect memory starts after last voice\n                this.$effect = this.dspVoices$[this.voices - 1] + this.dspMeta.size;\n            }\n\n            this.pathTable$ = {};\n\n            this.$buffer = 0;\n            this.cachedEvents = [];\n\n            // Init resulting DSP\n            this.setup();\n        }\n        instantiateWasm(options: { id: string; voices: number; compiledDsp: TCompiledDsp; mixer32Module: WebAssembly.Module }) {\n            const memory = createWasmMemory(options.voices, options.compiledDsp.dspMeta, options.compiledDsp.effectMeta, 128);\n            this.memory = memory;\n            const imports = createWasmImport(options.voices, memory);\n            this.dspInstance = new WebAssembly.Instance(options.compiledDsp.dspModule, imports);\n            if (options.compiledDsp.effectModule) {\n                this.effectInstance = new WebAssembly.Instance(options.compiledDsp.effectModule, imports);\n            }\n            if (options.voices) {\n                const mixerImports = { imports: { print: console.log }, memory: { memory } };\n                this.mixerInstance = new WebAssembly.Instance(options.mixer32Module, mixerImports);\n            }\n        }\n        updateOutputs() {\n            if (this.outputsItems.length > 0 && this.outputHandler && this.outputsTimer-- === 0) {\n                this.outputsTimer = 5;\n                this.outputsItems.forEach(item => this.outputHandler(item, this.factory.getParamValue(this.$dsp, this.pathTable$[item])));\n            }\n        }\n\n        parseUI(ui: TFaustUI) {\n            return FaustAudioWorkletProcessor.parseUI(ui, this, FaustAudioWorkletProcessor.parseItem2);\n        }\n        parseGroup(group: TFaustUIGroup) {\n            return FaustAudioWorkletProcessor.parseGroup(group, this, FaustAudioWorkletProcessor.parseItem2);\n        }\n        parseItems(items: TFaustUIItem[]) {\n            return FaustAudioWorkletProcessor.parseItems(items, this, FaustAudioWorkletProcessor.parseItem2);\n        }\n        parseItem(item: TFaustUIItem) {\n            return FaustAudioWorkletProcessor.parseItem2(item, this, FaustAudioWorkletProcessor.parseItem2);\n        }\n\n        setParamValue(path: string, val: number) {\n            if (this.voices) {\n                if (this.effect && findPath(this.effectMeta.ui, path)) this.effect.setParamValue(this.$effect, this.pathTable$[path], val);\n                else this.dspVoices$.forEach($voice => this.factory.setParamValue($voice, this.pathTable$[path], val));\n            } else {\n                this.factory.setParamValue(this.$dsp, this.pathTable$[path], val);\n            }\n        }\n        getParamValue(path: string) {\n            if (this.voices) {\n                if (this.effect && findPath(this.effectMeta.ui, path)) return this.effect.getParamValue(this.$effect, this.pathTable$[path]);\n                return this.factory.getParamValue(this.dspVoices$[0], this.pathTable$[path]);\n            }\n            return this.factory.getParamValue(this.$dsp, this.pathTable$[path]);\n        }\n        setup() {\n            if (this.numIn > 0) {\n                this.$ins = this.$$audioHeapInputs;\n                for (let i = 0; i < this.numIn; i++) {\n                    this.HEAP32[(this.$ins >> 2) + i] = this.$audioHeapInputs + this.bufferSize * this.sampleSize * i;\n                }\n                // Prepare Ins buffer tables\n                const dspInChans = this.HEAP32.subarray(this.$ins >> 2, (this.$ins + this.numIn * this.ptrSize) >> 2);\n                for (let i = 0; i < this.numIn; i++) {\n                    this.dspInChannnels[i] = this.HEAPF32.subarray(dspInChans[i] >> 2, (dspInChans[i] + this.bufferSize * this.sampleSize) >> 2);\n                }\n            }\n            if (this.numOut > 0) {\n                this.$outs = this.$$audioHeapOutputs;\n                if (this.voices) this.$mixing = this.$$audioHeapMixing;\n                for (let i = 0; i < this.numOut; i++) {\n                    this.HEAP32[(this.$outs >> 2) + i] = this.$audioHeapOutputs + this.bufferSize * this.sampleSize * i;\n                    if (this.voices) this.HEAP32[(this.$mixing >> 2) + i] = this.$audioHeapMixing + this.bufferSize * this.sampleSize * i;\n                }\n                // Prepare Out buffer tables\n                const dspOutChans = this.HEAP32.subarray(this.$outs >> 2, (this.$outs + this.numOut * this.ptrSize) >> 2);\n                for (let i = 0; i < this.numOut; i++) {\n                    this.dspOutChannnels[i] = this.HEAPF32.subarray(dspOutChans[i] >> 2, (dspOutChans[i] + this.bufferSize * this.sampleSize) >> 2);\n                }\n            }\n            // Parse UI\n            this.parseUI(this.dspMeta.ui);\n            if (this.effect) this.parseUI(this.effectMeta.ui);\n\n            // keep 'keyOn/keyOff' labels\n            if (this.voices) {\n                this.inputsItems.forEach((item) => {\n                    if (item.endsWith(\"/gate\")) this.fGateLabel$.push(this.pathTable$[item]);\n                    else if (item.endsWith(\"/freq\")) this.fFreqLabel$.push(this.pathTable$[item]);\n                    else if (item.endsWith(\"/gain\")) this.fGainLabel$.push(this.pathTable$[item]);\n                });\n                // Init DSP voices\n                this.dspVoices$.forEach($voice => this.factory.init($voice, sampleRate));\n                // Init effect\n                if (this.effect) this.effect.init(this.$effect, sampleRate);\n            } else {\n                // Init DSP\n                this.factory.init(this.$dsp, sampleRate); // 'sampleRate' is defined in AudioWorkletGlobalScope\n            }\n        }\n        // Poly only methods\n        getPlayingVoice(pitch: number) {\n            if (!this.voices) return null;\n            let voice = this.kNoVoice;\n            let oldestDatePlaying = Number.MAX_VALUE;\n            for (let i = 0; i < this.voices; i++) {\n                if (this.dspVoicesState[i] === pitch) {\n                    // Keeps oldest playing voice\n                    if (this.dspVoicesDate[i] < oldestDatePlaying) {\n                        oldestDatePlaying = this.dspVoicesDate[i];\n                        voice = i;\n                    }\n                }\n            }\n            return voice;\n        }\n        allocVoice(voice: number) {\n            if (!this.voices) return null;\n            // so that envelop is always re-initialized\n            this.factory.instanceClear(this.dspVoices$[voice]);\n            this.dspVoicesDate[voice] = this.fDate++;\n            this.dspVoicesState[voice] = this.kActiveVoice;\n            return voice;\n        }\n        getFreeVoice() {\n            if (!this.voices) return null;\n            for (let i = 0; i < this.voices; i++) {\n                if (this.dspVoicesState[i] === this.kFreeVoice) return this.allocVoice(i);\n            }\n            let voiceRelease = this.kNoVoice;\n            let voicePlaying = this.kNoVoice;\n            let oldestDateRelease = Number.MAX_VALUE;\n            let oldestDatePlaying = Number.MAX_VALUE;\n            for (let i = 0; i < this.voices; i++) { // Scan all voices\n                // Try to steal a voice in kReleaseVoice mode...\n                if (this.dspVoicesState[i] === this.kReleaseVoice) {\n                    // Keeps oldest release voice\n                    if (this.dspVoicesDate[i] < oldestDateRelease) {\n                        oldestDateRelease = this.dspVoicesDate[i];\n                        voiceRelease = i;\n                    }\n                } else if (this.dspVoicesDate[i] < oldestDatePlaying) {\n                    oldestDatePlaying = this.dspVoicesDate[i];\n                    voicePlaying = i;\n                }\n            }\n            // Then decide which one to steal\n            if (oldestDateRelease !== Number.MAX_VALUE) {\n                // console.log(`Steal release voice : voice_date = ${this.dspVoicesDate[voiceRelease]} cur_date = ${this.fDate} voice = ${voiceRelease}`);\n                return this.allocVoice(voiceRelease);\n            }\n            if (oldestDatePlaying !== Number.MAX_VALUE) {\n                // console.log(`Steal playing voice : voice_date = ${this.dspVoicesDate[voicePlaying]} cur_date = ${this.fDate} voice = ${voicePlaying}`);\n                return this.allocVoice(voicePlaying);\n            }\n            return this.kNoVoice;\n        }\n        keyOn(channel: number, pitch: number, velocity: number) {\n            if (!this.voices) return;\n            const voice = this.getFreeVoice();\n            // console.log(\"keyOn voice \" + voice);\n            this.fFreqLabel$.forEach($ => this.factory.setParamValue(this.dspVoices$[voice], $, midiToFreq(pitch)));\n            this.fGateLabel$.forEach($ => this.factory.setParamValue(this.dspVoices$[voice], $, 1));\n            this.fGainLabel$.forEach($ => this.factory.setParamValue(this.dspVoices$[voice], $, velocity / 127));\n            this.dspVoicesState[voice] = pitch;\n        }\n        keyOff(channel: number, pitch: number, velocity: number) {\n            if (!this.voices) return;\n            const voice = this.getPlayingVoice(pitch);\n            if (voice === this.kNoVoice) return; // console.log(\"Playing voice not found...\");\n            // console.log(\"keyOff voice \" + voice);\n            this.fGateLabel$.forEach($ => this.factory.setParamValue(this.dspVoices$[voice], $, 0)); // No use of velocity for now...\n            this.dspVoicesState[voice] = this.kReleaseVoice; // Release voice\n        }\n        allNotesOff() {\n            if (!this.voices) return;\n            for (let i = 0; i < this.voices; i++) {\n                this.fGateLabel$.forEach($gate => this.factory.setParamValue(this.dspVoices$[i], $gate, 0));\n                this.dspVoicesState[i] = this.kReleaseVoice;\n            }\n        }\n\n        midiMessage(data: number[] | Uint8Array) {\n            const cmd = data[0] >> 4;\n            const channel = data[0] & 0xf;\n            const data1 = data[1];\n            const data2 = data[2];\n            if (channel === 9) return;\n            if (cmd === 8 || (cmd === 9 && data2 === 0)) this.keyOff(channel, data1, data2);\n            else if (cmd === 9) this.keyOn(channel, data1, data2);\n            else if (cmd === 11) this.ctrlChange(channel, data1, data2);\n            else if (cmd === 14) this.pitchWheel(channel, data2 * 128.0 + data1);\n        }\n        ctrlChange(channel: number, ctrl: number, value: number) {\n            if (!this.fCtrlLabel[ctrl].length) return;\n            this.fCtrlLabel[ctrl].forEach((ctrl) => {\n                const { path } = ctrl;\n                this.setParamValue(path, remap(value, 0, 127, ctrl.min, ctrl.max));\n                if (this.outputHandler) this.outputHandler(path, this.getParamValue(path));\n            });\n        }\n        pitchWheel(channel: number, wheel: number) {\n            this.fPitchwheelLabel.forEach((pw) => {\n                this.setParamValue(pw.path, remap(wheel, 0, 16383, pw.min, pw.max));\n                if (this.outputHandler) this.outputHandler(pw.path, this.getParamValue(pw.path));\n            });\n        }\n        process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: { [key: string]: Float32Array }) {\n            if (this.destroyed) return false;\n            const input = inputs[0];\n            const output = outputs[0];\n            // Check inputs\n            if (this.numIn > 0 && (!input || !input[0] || input[0].length === 0)) {\n                // console.log(\"Process input error\");\n                return true;\n            }\n            // Check outputs\n            if (this.numOut > 0 && (!output || !output[0] || output[0].length === 0)) {\n                // console.log(\"Process output error\");\n                return true;\n            }\n            // Copy inputs\n            if (input !== undefined) {\n                for (let chan = 0; chan < Math.min(this.numIn, input.length); ++chan) {\n                    const dspInput = this.dspInChannnels[chan];\n                    dspInput.set(input[chan]);\n                }\n            }\n            // Update controls (possibly needed for sample accurate control)\n            for (const path in parameters) {\n                const paramArray = parameters[path];\n                this.setParamValue(path, paramArray[0]);\n            }\n            // Possibly call an externally given callback (for instance to synchronize playing a MIDIFile...)\n            if (this.computeHandler) this.computeHandler(this.bufferSize);\n            if (this.voices) {\n                this.mixer.clearOutput(this.bufferSize, this.numOut, this.$outs); // First clear the outputs\n                for (let i = 0; i < this.voices; i++) { // Compute all running voices\n                    this.factory.compute(this.dspVoices$[i], this.bufferSize, this.$ins, this.$mixing); // Compute voice\n                    this.mixer.mixVoice(this.bufferSize, this.numOut, this.$mixing, this.$outs); // Mix it in result\n                }\n                if (this.effect) this.effect.compute(this.$effect, this.bufferSize, this.$outs, this.$outs); // Apply effect. Not a typo, effect is applied on the outs.\n            } else {\n                this.factory.compute(this.$dsp, this.bufferSize, this.$ins, this.$outs); // Compute\n            }\n            // Update bargraph\n            this.updateOutputs();\n            // Copy outputs\n            if (output !== undefined) {\n                for (let i = 0; i < Math.min(this.numOut, output.length); i++) {\n                    const dspOutput = this.dspOutChannnels[i];\n                    output[i].set(dspOutput);\n                }\n                this.port.postMessage({ type: \"plot\", value: output, index: this.$buffer++, events: this.cachedEvents });\n                this.cachedEvents = [];\n            }\n            return true;\n        }\n        printMemory() {\n            console.log(\"============== Memory layout ==============\");\n            console.log(\"dspMeta.size: \" + this.dspMeta.size);\n            console.log(\"$audioHeap: \" + this.$audioHeap);\n            console.log(\"$$audioHeapInputs: \" + this.$$audioHeapInputs);\n            console.log(\"$$audioHeapOutputs: \" + this.$$audioHeapOutputs);\n            console.log(\"$$audioHeapMixing: \" + this.$$audioHeapMixing);\n            console.log(\"$audioHeapInputs: \" + this.$audioHeapInputs);\n            console.log(\"$audioHeapOutputs: \" + this.$audioHeapOutputs);\n            console.log(\"$audioHeapMixing: \" + this.$audioHeapMixing);\n            console.log(\"$dsp: \" + this.$dsp);\n            if (this.dspVoices$) this.dspVoices$.forEach(($voice, i) => console.log(\"dspVoices$[\" + i + \"]: \" + $voice));\n            console.log(\"$effect: \" + this.$effect);\n            console.log(\"$mixing: \" + this.$mixing);\n        }\n    }\n\n    // Globals\n    // Synchronously compile and instantiate the WASM module\n    registerProcessor(FaustConst.id || \"mydsp\", FaustAudioWorkletProcessor);\n};\n","/* eslint-disable object-curly-newline */\n/* eslint-disable object-property-newline */\nimport { TDspMeta, TCompiledDsp, TFaustUI, TFaustUIGroup, TFaustUIItem } from \"./types\";\nimport { remap } from \"./utils\";\n\nexport class FaustAudioWorkletNode extends (window.AudioWorkletNode ? AudioWorkletNode : null) {\n    onprocessorerror = (e: ErrorEvent) => {\n        console.error(\"Error from \" + this.dspMeta.name + \" AudioWorkletNode: \"); // eslint-disable-line no-console\n        throw e.error;\n    }\n    /* WAP ??\n    getMetadata = this.getJSON;\n    setParam = this.setParamValue;\n    getParam = this.getParamValue;\n    inputChannelCount = this.getNumInputs;\n    outputChannelCount = this.getNumOutputs;\n    getParams = () => this.inputsItems;\n    getDescriptor = this.getParams;\n    onMidi = this.midiMessage;\n    getState = async () => {\n        const params = {} as { [key: string]: string };\n        this.getDescriptor().forEach(key => params[key] = JSON.stringify(this.getParam(key)));\n        return params;\n    }\n    setState = async (state: { [key: string]: number; }) => {\n        for (const key in state) {\n            this.setParam(key, state[key]);\n        }\n        try {\n            this.gui.setAttribute(\"state\", JSON.stringify(state));\n        } catch (error) {\n            console.warn(\"Plugin without gui or GUI not defined: \", error);\n        }\n        return state;\n    }\n    setPatch = (patch: any) => this.presets ? this.setState(this.presets[patch]) : undefined; // ??\n    metadata = (handler: (...args: any[]) => any) => handler(null);\n    gui: any;\n    presets: any;\n    */\n\n    voices?: number;\n    dspMeta: TDspMeta;\n    effectMeta: TDspMeta;\n    outputHandler: (address: string, value: number) => any;\n    inputsItems: string[];\n    outputsItems: string[];\n\n    fPitchwheelLabel: { path: string; min: number; max: number }[];\n    fCtrlLabel: { path: string; min: number; max: number }[][];\n\n    plotHandler: (plotted: Float32Array[], index: number, events?: { type: string; data: any }[]) => any;\n\n    constructor(options: { audioCtx: AudioContext; id: string; compiledDsp: TCompiledDsp; voices?: number; plotHandler?: (plotted: Float32Array[], index: number, events?: { type: string; data: any }[]) => any; mixer32Module: WebAssembly.Module }) {\n        super(options.audioCtx, options.id, {\n            numberOfInputs: options.compiledDsp.dspMeta.inputs > 0 ? 1 : 0,\n            numberOfOutputs: options.compiledDsp.dspMeta.outputs > 0 ? 1 : 0,\n            channelCount: Math.max(1, options.compiledDsp.dspMeta.inputs),\n            outputChannelCount: [options.compiledDsp.dspMeta.outputs],\n            channelCountMode: \"explicit\",\n            channelInterpretation: \"speakers\",\n            processorOptions: { id: options.id, voices: options.voices, compiledDsp: options.compiledDsp, mixer32Module: options.mixer32Module }\n        });\n        // Patch it with additional functions\n        this.port.onmessage = (e: MessageEvent) => {\n            if (e.data.type === \"param\" && this.outputHandler) {\n                this.outputHandler(e.data.path, e.data.value);\n            } else if (e.data.type === \"plot\") {\n                if (this.plotHandler) this.plotHandler(e.data.value, e.data.index, e.data.events);\n            }\n        };\n        this.voices = options.voices;\n        this.dspMeta = options.compiledDsp.dspMeta;\n        this.effectMeta = options.compiledDsp.effectMeta;\n        this.outputHandler = null;\n        this.inputsItems = [];\n        this.outputsItems = [];\n        this.fPitchwheelLabel = [];\n        this.fCtrlLabel = new Array(128).fill(null).map(() => []);\n        this.plotHandler = options.plotHandler;\n        this.parseUI(this.dspMeta.ui);\n        if (this.effectMeta) this.parseUI(this.effectMeta.ui);\n        try {\n            if (this.parameters) this.parameters.forEach(p => p.automationRate = \"k-rate\");\n        } catch (e) {} // eslint-disable-line no-empty\n    }\n    parseUI(ui: TFaustUI) {\n        ui.forEach(group => this.parseGroup(group));\n    }\n    parseGroup(group: TFaustUIGroup) {\n        if (group.items) this.parseItems(group.items);\n    }\n    parseItems(items: TFaustUIItem[]) {\n        items.forEach(item => this.parseItem(item));\n    }\n    parseItem(item: TFaustUIItem) {\n        if (item.type === \"vgroup\" || item.type === \"hgroup\" || item.type === \"tgroup\") {\n            this.parseItems(item.items);\n        } else if (item.type === \"hbargraph\" || item.type === \"vbargraph\") {\n            // Keep bargraph adresses\n            this.outputsItems.push(item.address);\n        } else if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"button\" || item.type === \"checkbox\" || item.type === \"nentry\") {\n            // Keep inputs adresses\n            this.inputsItems.push(item.address);\n            if (!item.meta) return;\n            item.meta.forEach((meta) => {\n                const { midi } = meta;\n                if (!midi) return;\n                const strMidi = midi.trim();\n                if (strMidi === \"pitchwheel\") {\n                    this.fPitchwheelLabel.push({ path: item.address, min: item.min, max: item.max });\n                } else {\n                    const matched = strMidi.match(/^ctrl\\s(\\d+)/);\n                    if (!matched) return;\n                    this.fCtrlLabel[parseInt(matched[1])].push({ path: item.address, min: item.min, max: item.max });\n                }\n            });\n        }\n    }\n\n    /**\n     * Instantiates a new polyphonic voice.\n     *\n     * @param {number} channel - the MIDI channel (0..15, not used for now)\n     * @param {number} pitch - the MIDI pitch (0..127)\n     * @param {number} velocity - the MIDI velocity (0..127)\n     * @memberof FaustAudioWorkletNode\n     */\n    keyOn(channel: number, pitch: number, velocity: number) {\n        const e = { type: \"keyOn\", data: [channel, pitch, velocity] };\n        this.port.postMessage(e);\n    }\n    /**\n     * De-instantiates a polyphonic voice.\n     *\n     * @param {number} channel - the MIDI channel (0..15, not used for now)\n     * @param {number} pitch - the MIDI pitch (0..127)\n     * @param {number} velocity - the MIDI velocity (0..127)\n     * @memberof FaustAudioWorkletNode\n     */\n    keyOff(channel: number, pitch: number, velocity: number) {\n        const e = { type: \"keyOff\", data: [channel, pitch, velocity] };\n        this.port.postMessage(e);\n    }\n    /**\n     * Gently terminates all the active voices.\n     *\n     * @memberof FaustAudioWorkletNode\n     */\n    allNotesOff() {\n        const e = { type: \"ctrlChange\", data: [0, 123, 0] };\n        this.port.postMessage(e);\n    }\n    ctrlChange(channel: number, ctrlIn: number, valueIn: any) {\n        const e = { type: \"ctrlChange\", data: [channel, ctrlIn, valueIn] };\n        this.port.postMessage(e);\n        if (!this.fCtrlLabel[ctrlIn].length) return;\n        this.fCtrlLabel[ctrlIn].forEach((ctrl) => {\n            const { path } = ctrl;\n            const value = remap(valueIn, 0, 127, ctrl.min, ctrl.max);\n            const param = this.parameters.get(path);\n            if (param) param.setValueAtTime(value, this.context.currentTime);\n        });\n    }\n    pitchWheel(channel: number, wheel: number) {\n        const e = { type: \"pitchWheel\", data: [channel, wheel] };\n        this.port.postMessage(e);\n        this.fPitchwheelLabel.forEach((pw) => {\n            const { path } = pw;\n            const value = remap(wheel, 0, 16383, pw.min, pw.max);\n            const param = this.parameters.get(path);\n            if (param) param.setValueAtTime(value, this.context.currentTime);\n        });\n    }\n    midiMessage(data: number[] | Uint8Array) {\n        const cmd = data[0] >> 4;\n        const channel = data[0] & 0xf;\n        const data1 = data[1];\n        const data2 = data[2];\n        if (channel === 9) return;\n        if (cmd === 8 || (cmd === 9 && data2 === 0)) this.keyOff(channel, data1, data2);\n        else if (cmd === 9) this.keyOn(channel, data1, data2);\n        else if (cmd === 11) this.ctrlChange(channel, data1, data2);\n        else if (cmd === 14) this.pitchWheel(channel, data2 * 128.0 + data1);\n        else this.port.postMessage({ data, type: \"midi\" });\n    }\n    metadata() {}\n    setParamValue(path: string, value: number) {\n        const e = { type: \"param\", data: { path, value } };\n        this.port.postMessage(e);\n        const param = this.parameters.get(path);\n        if (param) param.setValueAtTime(value, this.context.currentTime);\n    }\n    getParamValue(path: string) {\n        const param = this.parameters.get(path);\n        if (param) return param.value;\n        return null;\n    }\n    setOutputParamHandler(handler: (address: string, value: number) => any) {\n        this.outputHandler = handler;\n    }\n    getOutputParamHandler() {\n        return this.outputHandler;\n    }\n    getNumInputs() {\n        return this.dspMeta.inputs;\n    }\n    getNumOutputs() {\n        return this.dspMeta.outputs;\n    }\n    getParams() {\n        return this.inputsItems;\n    }\n    getJSON() {\n        if (this.voices) {\n            const o = this.dspMeta;\n            const e = this.effectMeta;\n            const r = { ...o };\n            if (e) {\n                r.ui = [{ type: \"tgroup\", label: \"Sequencer\", items: [\n                    { type: \"vgroup\", label: \"Instrument\", items: o.ui },\n                    { type: \"vgroup\", label: \"Effect\", items: e.ui }\n                ] }];\n            } else {\n                r.ui = [{ type: \"tgroup\", label: \"Polyphonic\", items: [\n                    { type: \"vgroup\", label: \"Voices\", items: o.ui }\n                ] }];\n            }\n            return JSON.stringify(r);\n        }\n        return JSON.stringify(this.dspMeta);\n    }\n    getUI() {\n        if (this.voices) {\n            const o = this.dspMeta;\n            const e = this.effectMeta;\n            if (e) {\n                return [{ type: \"tgroup\", label: \"Sequencer\", items: [\n                    { type: \"vgroup\", label: \"Instrument\", items: o.ui },\n                    { type: \"vgroup\", label: \"Effect\", items: e.ui }\n                ] }];\n            }\n            return [{ type: \"tgroup\", label: \"Polyphonic\", items: [\n                { type: \"vgroup\", label: \"Voices\", items: o.ui }\n            ] }];\n        }\n        return this.dspMeta.ui;\n    }\n    destroy() {\n        this.port.postMessage({ type: \"destroy\" });\n        this.port.close();\n        delete this.plotHandler;\n        delete this.outputHandler;\n    }\n}\n","/* eslint-disable no-restricted-properties */\n/* eslint-disable @typescript-eslint/camelcase */\n/* eslint-disable object-property-newline */\nimport { TDspMeta, FaustWebAssemblyExports, TCompiledDsp } from \"./types\";\n\nexport class FaustOfflineProcessor {\n    private bufferSize = 1024;\n    private sampleRate: number;\n    private dspMeta: TDspMeta;\n    private $ins: number;\n    private $outs: number;\n    private dspInChannnels: Float32Array[];\n    private dspOutChannnels: Float32Array[];\n    private numIn: number;\n    private numOut: number;\n    private ptrSize: number;\n    private sampleSize: number;\n    private $audioHeap: number;\n    private $$audioHeapInputs: number;\n    private $$audioHeapOutputs: number;\n    private $audioHeapInputs: number;\n    private $audioHeapOutputs: number;\n    private $dsp: number;\n    private factory: FaustWebAssemblyExports;\n    private HEAP: ArrayBuffer;\n    private HEAP32: Int32Array;\n    private HEAPF32: Float32Array;\n    private output: Float32Array[];\n\n    static get importObject() {\n        return {\n            env: {\n                memory: undefined as WebAssembly.Memory, memoryBase: 0, tableBase: 0,\n                _abs: Math.abs,\n                // Float version\n                _acosf: Math.acos, _asinf: Math.asin, _atanf: Math.atan, _atan2f: Math.atan2,\n                _ceilf: Math.ceil, _cosf: Math.cos, _expf: Math.exp, _floorf: Math.floor,\n                _fmodf: (x: number, y: number) => x % y,\n                _logf: Math.log, _log10f: Math.log10, _max_f: Math.max, _min_f: Math.min,\n                _remainderf: (x: number, y: number) => x - Math.round(x / y) * y,\n                _powf: Math.pow, _roundf: Math.fround, _sinf: Math.sin, _sqrtf: Math.sqrt, _tanf: Math.tan,\n                _acoshf: Math.acosh, _asinhf: Math.asinh, _atanhf: Math.atanh,\n                _coshf: Math.cosh, _sinhf: Math.sinh, _tanhf: Math.tanh,\n                // Double version\n                _acos: Math.acos, _asin: Math.asin, _atan: Math.atan, _atan2: Math.atan2,\n                _ceil: Math.ceil, _cos: Math.cos, _exp: Math.exp, _floor: Math.floor,\n                _fmod: (x: number, y: number) => x % y,\n                _log: Math.log, _log10: Math.log10, _max_: Math.max, _min_: Math.min,\n                _remainder: (x: number, y: number) => x - Math.round(x / y) * y,\n                _pow: Math.pow, _round: Math.fround, _sin: Math.sin, _sqrt: Math.sqrt, _tan: Math.tan,\n                _acosh: Math.acosh, _asinh: Math.asinh, _atanh: Math.atanh,\n                _cosh: Math.cosh, _sinh: Math.sinh, _tanh: Math.tanh,\n                table: new WebAssembly.Table({ initial: 0, element: \"anyfunc\" })\n            }\n        };\n    }\n    async init(options: { compiledDsp?: TCompiledDsp; sampleRate?: number }) {\n        const { compiledDsp } = options;\n        if (!compiledDsp) throw new Error(\"No Dsp input\");\n\n        this.dspMeta = compiledDsp.dspMeta;\n\n        this.$ins = null;\n        this.$outs = null;\n\n        this.dspInChannnels = [];\n        this.dspOutChannnels = [];\n\n        this.numIn = this.dspMeta.inputs;\n        this.numOut = this.dspMeta.outputs;\n        // Memory allocator\n        this.ptrSize = 4;\n        this.sampleSize = 4;\n\n        // Create the WASM instance\n        const dspInstance = await WebAssembly.instantiate(compiledDsp.dspModule, FaustOfflineProcessor.importObject);\n        this.factory = dspInstance.exports as FaustWebAssemblyExports;\n        this.HEAP = this.factory.memory.buffer;\n        this.HEAP32 = new Int32Array(this.HEAP);\n        this.HEAPF32 = new Float32Array(this.HEAP);\n\n        this.output = new Array(this.numOut).fill(null).map(() => new Float32Array(this.bufferSize));\n    }\n    setup(options?: { sampleRate?: number }) {\n        if (!this.dspMeta) throw new Error(\"No Dsp\");\n        this.sampleRate = options && options.sampleRate || 48000;\n\n        // DSP is placed first with index 0. Audio buffer start at the end of DSP.\n        this.$audioHeap = this.dspMeta.size;\n\n        // Setup pointers offset\n        this.$$audioHeapInputs = this.$audioHeap;\n        this.$$audioHeapOutputs = this.$$audioHeapInputs + this.numIn * this.ptrSize;\n\n        // Setup buffer offset\n        this.$audioHeapInputs = this.$$audioHeapOutputs + (this.numOut * this.ptrSize);\n        this.$audioHeapOutputs = this.$audioHeapInputs + (this.numIn * this.bufferSize * this.sampleSize);\n        // Start of DSP memory : Mono DSP is placed first with index 0\n        this.$dsp = 0;\n\n        if (this.numIn > 0) {\n            this.$ins = this.$$audioHeapInputs;\n            for (let i = 0; i < this.numIn; i++) {\n                this.HEAP32[(this.$ins >> 2) + i] = this.$audioHeapInputs + this.bufferSize * this.sampleSize * i;\n            }\n            // Prepare Ins buffer tables\n            const dspInChans = this.HEAP32.subarray(this.$ins >> 2, (this.$ins + this.numIn * this.ptrSize) >> 2);\n            for (let i = 0; i < this.numIn; i++) {\n                this.dspInChannnels[i] = this.HEAPF32.subarray(dspInChans[i] >> 2, (dspInChans[i] + this.bufferSize * this.sampleSize) >> 2);\n            }\n        }\n        if (this.numOut > 0) {\n            this.$outs = this.$$audioHeapOutputs;\n            for (let i = 0; i < this.numOut; i++) {\n                this.HEAP32[(this.$outs >> 2) + i] = this.$audioHeapOutputs + this.bufferSize * this.sampleSize * i;\n            }\n            // Prepare Out buffer tables\n            const dspOutChans = this.HEAP32.subarray(this.$outs >> 2, (this.$outs + this.numOut * this.ptrSize) >> 2);\n            for (let i = 0; i < this.numOut; i++) {\n                this.dspOutChannnels[i] = this.HEAPF32.subarray(dspOutChans[i] >> 2, (dspOutChans[i] + this.bufferSize * this.sampleSize) >> 2);\n            }\n        }\n        // Init DSP\n        this.factory.init(this.$dsp, this.sampleRate);\n    }\n    compute() {\n        if (!this.factory) return this.output;\n        for (let i = 0; i < this.numIn; i++) {\n            this.dspInChannnels[i].fill(0);\n        }\n        this.factory.compute(this.$dsp, this.bufferSize, this.$ins, this.$outs); // Compute\n        // Copy outputs\n        if (this.output !== undefined) {\n            for (let i = 0; i < this.numOut; i++) {\n                this.output[i].set(this.dspOutChannnels[i]);\n            }\n        }\n        return this.output;\n    }\n    async plot(options?: { compiledDsp?: TCompiledDsp; size?: number; sampleRate?: number }) {\n        if (options && options.compiledDsp) await this.init(options);\n        this.setup(options);\n        const size = options && options.size || 128;\n        const plotted = new Array(this.numOut).fill(null).map(() => new Float32Array(size));\n        for (let i = 0; i < size; i += this.bufferSize) {\n            const computed = this.compute();\n            for (let j = 0; j < plotted.length; j++) {\n                plotted[j].set(size - i > this.bufferSize ? computed[j] : computed[j].subarray(0, size - i), i);\n            }\n        }\n        return plotted;\n    }\n}\n","/* eslint-disable no-console */\nimport sha1 from \"crypto-libraries/sha1\";\nimport { LibFaustLoader, LibFaust } from \"./LibFaustLoader\";\nimport { FaustWasmToScriptProcessor } from \"./FaustWasmToScriptProcessor\";\nimport { FaustAudioWorkletProcessorWrapper } from \"./FaustAudioWorkletProcessor\";\nimport { FaustAudioWorkletNode } from \"./FaustAudioWorkletNode\";\n\nimport * as utils from \"./utils\";\nimport { FaustOfflineProcessor } from \"./FaustOfflineProcessor\";\nimport { TCompiledDsp, TFaustCompileOptions, FaustScriptProcessorNode, TFaustCompileArgs, TCompiledCode, TCompiledCodes, TAudioNodeOptions, TCompiledStrCodes } from \"./types\";\n\n// import * as Binaryen from \"binaryen\";\n\n///<reference path=\"libfaust.d.ts\"/>\n\n/**\n * Main Faust class,\n * usage: `new Faust().ready.then(faust => any);`\n *\n * @export\n * @class Faust\n */\nexport class Faust {\n    /**\n     * The libfaust Wasm Emscripten Module\n     *\n     * @private\n     * @type {LibFaust}\n     * @memberof Faust\n     */\n    private libFaust: LibFaust;\n    // private createWasmCDSPFactoryFromString: ($name: number, $code: number, argc: number, $argv: number, $errorMsg: number, internalMemory: boolean) => number;\n    // private deleteAllWasmCDSPFactories: () => void;\n    // private expandCDSPFromString: ($name: number, $code: number, argc: number, $argv: number, $shaKey: number, $errorMsg: number) => number;\n    // private getCLibFaustVersion: () => number;\n    // private getWasmCModule: ($moduleCode: number) => number;\n    // private getWasmCModuleSize: ($moduleCode: number) => number;\n    // private getWasmCHelpers: ($moduleCode: number) => number;\n    // private freeWasmCModule: ($moduleCode: number) => void;\n    // private freeCMemory: ($: number) => number;\n    // private cleanupAfterException: () => void;\n    // private getErrorAfterException: () => number;\n    // private getLibFaustVersion: () => string;\n    // private generateCAuxFilesFromString: ($name: number, $code: number, argc: number, $argv: number, $errorMsg: number) => number;\n    /**\n     * Debug mode, set to true to print out each message\n     *\n     * @type {boolean}\n     * @memberof Faust\n     */\n    debug: boolean = false;\n    /**\n     * An object to storage compiled dsp with it's sha1\n     *\n     * @private\n     * @type {{ [shaKey: string]: TCompiledDsp }}\n     * @memberof Faust\n     */\n    private dspTable: { [shaKey: string]: TCompiledDsp } = {};\n    /**\n     * Registered WorkletProcessor names\n     *\n     * @private\n     * @type {string[]}\n     * @memberof Faust\n     */\n    private workletProcessors: string[] = [];\n    private _log: string[] = [];\n    /**\n     * Offline processor used to plot\n     *\n     * @private\n     * @type {FaustOfflineProcessor}\n     * @memberof Faust\n     */\n    private offlineProcessor: FaustOfflineProcessor = new FaustOfflineProcessor();\n    /**\n     * Location of `libfaust-wasm.wasm`\n     *\n     * @private\n     * @type {string}\n     * @memberof Faust\n     */\n    private wasmLocation: string;\n    /**\n     * Location of `libfaust-wasm.data`\n     *\n     * @private\n     * @type {string}\n     * @memberof Faust\n     */\n    private dataLocation: string;\n\n    /**\n     * Creates an instance of Faust\n     * usage: `new Faust().ready.then(faust => any);`\n     *\n     * @param {{ debug?: boolean; wasmLocation?: string; dataLocation?: string }} [options]\n     * @memberof Faust\n     */\n    constructor(debug: boolean, lib: LibFaust) {\n        this.debug = debug;\n        this.libFaust = lib;\n    }\n    /**\n     * Load a libfaust module\n     *\n     * @returns {Promise<Faust>}\n     * @memberof Faust\n     */\n    // async loadLibFaust(): Promise<Faust> {\n    //     if (this.libFaust) return this;\n    //     // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    //     // @ts-ignore\n    //     this.libFaust = await LibFaustLoader.load(this.wasmLocation, this.dataLocation);\n    //     // this.importLibFaustFunctions();\n    //     return this;\n    // }\n    /**\n     * A promise to resolve when libfaust is ready.\n     *\n     * @readonly\n     * @type {Promise<Faust>}\n     * @memberof Faust\n     */\n    // get ready(): Promise<Faust> {\n    //     return this.loadLibFaust();\n    // }\n    // private importLibFaustFunctions(): void {\n    //     if (!this.libFaust) return;\n        // this.cleanupAfterException = this.libFaust.cwrap(\"cleanupAfterException\", null, []);\n        // this.getErrorAfterException = this.libFaust.cwrap(\"getErrorAfterException\", \"number\", []);\n\n        // this.createWasmCDSPFactoryFromString = this.libFaust.cwrap(\"createWasmCDSPFactoryFromString\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\", \"number\"]);\n        // this.deleteAllWasmCDSPFactories = this.libFaust.cwrap(\"deleteAllWasmCDSPFactories\", null, []);\n        // this.expandCDSPFromString = this.libFaust.cwrap(\"expandCDSPFromString\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\", \"number\"]);\n        // this.getCLibFaustVersion = this.libFaust.cwrap(\"getCLibFaustVersion\", \"number\", []);\n        // this.getWasmCModule = this.libFaust.cwrap(\"getWasmCModule\", \"number\", [\"number\"]);\n        // this.getWasmCModuleSize = this.libFaust.cwrap(\"getWasmCModuleSize\", \"number\", [\"number\"]);\n        // this.getWasmCHelpers = this.libFaust.cwrap(\"getWasmCHelpers\", \"number\", [\"number\"]);\n        // this.freeWasmCModule = this.libFaust.cwrap(\"freeWasmCModule\", null, [\"number\"]);\n        // this.freeCMemory = this.libFaust.cwrap(\"freeCMemory\", null, [\"number\"]);\n        // this.cleanupAfterException = this.libFaust.cwrap(\"cleanupAfterException\", null, []);\n        // this.getErrorAfterException = this.libFaust.cwrap(\"getErrorAfterException\", \"number\", []);\n        // this.getLibFaustVersion = () => this.libFaust.UTF8ToString(this.getCLibFaustVersion());\n        // this.generateCAuxFilesFromString = this.libFaust.cwrap(\"generateCAuxFilesFromString\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"]);\n    // }\n    /**\n     * Create a AudioNode from dsp source code with options.\n     *\n     * @param {string} code - the source code\n     * @param {TFaustCompileOptions} optionsIn - options with audioCtx, bufferSize, voices, useWorklet, args, plot and plotHandler\n     * @returns {Promise<FaustAudioWorkletNode | FaustScriptProcessorNode>}\n     * @memberof Faust\n     */\n    async getNode(code: string, optionsIn: TFaustCompileOptions): Promise<FaustAudioWorkletNode | FaustScriptProcessorNode> {\n        const { audioCtx, voices, useWorklet, bufferSize, plotHandler, args } = optionsIn;\n        const argv = utils.toArgv(args);\n        const compiledDsp = await this.compileCodes(code, argv, !voices);\n        if (!compiledDsp) return null;\n        const options = { compiledDsp, audioCtx, voices, plotHandler, bufferSize: useWorklet ? 128 : bufferSize };\n        return useWorklet ? this.getAudioWorkletNode(options) : this.getScriptProcessorNode(options);\n    }\n    /**\n     * Get DSP information\n     *\n     * @param {string} code\n     * @param {{ voices?: number; args?: TFaustCompileArgs }} optionsIn\n     * @returns {Promise<TCompiledDsp>}\n     * @memberof Faust\n     */\n    async inspect(code: string, optionsIn: { voices?: number; args?: TFaustCompileArgs }): Promise<TCompiledDsp> {\n        const { voices, args } = optionsIn;\n        const argv = utils.toArgv(args);\n        return this.compileCodes(code, argv, !voices);\n    }\n    /**\n     * Plot a dsp offline.\n     *\n     * @param {{ code?: string; size?: number; sampleRate?: number; args?: TFaustCompileArgs }} [optionsIn]\n     * @returns {Promise<Float32Array[]>}\n     * @memberof Faust\n     */\n    async plot(optionsIn?: { code?: string; size?: number; sampleRate?: number; args?: TFaustCompileArgs }): Promise<Float32Array[]> {\n        let compiledDsp;\n        const argv = utils.toArgv(optionsIn.args);\n        if (optionsIn.code) {\n            compiledDsp = await this.compileCodes(optionsIn.code, argv, true);\n            if (!compiledDsp) return null;\n        }\n        return this.offlineProcessor.plot({ compiledDsp, ...optionsIn });\n    }\n    /**\n     * Generate Uint8Array and helpersCode from a dsp source code\n     *\n     * @private\n     * @param {string} factoryName - Class name of the source code\n     * @param {string} code - dsp source code\n     * @param {string[]} argvIn - Array of paramaters to be given to the Faust compiler\n     * @param {boolean} internalMemory - Use internal Memory flag, false for poly, true for mono\n     * @returns {TCompiledCode} - An object with ui8Code, code, helpersCode\n     * @memberof Faust\n     */\n    private compileCode(factoryName: string, code: string, argvIn: string[], internalMemory: boolean): TCompiledCode {\n        // const codeSize = this.libFaust.lengthBytesUTF8(code) + 1;\n        // const $code = this.libFaust._malloc(codeSize);\n        // const name = \"FaustDSP\";\n        // const nameSize = this.libFaust.lengthBytesUTF8(name) + 1;\n        // const $name = this.libFaust._malloc(nameSize);\n        // const $errorMsg = this.libFaust._malloc(4096);\n\n        // this.libFaust.stringToUTF8(name, $name, nameSize);\n        // this.libFaust.stringToUTF8(code, $code, codeSize);\n\n        // Add 'cn' option with the factory name\n        // const argv = argvIn || [];\n        // argv.push(\"-cn\", factoryName);\n\n        // // Prepare 'argv_aux' array for C side\n        // const ptrSize = 4;\n        // const $argv = this.libFaust._malloc(argv.length * ptrSize); // Get buffer from emscripten.\n        // let argvBuffer$ = new Int32Array(this.libFaust.HEAP32.buffer, $argv, argv.length); // Get a integer view on the newly allocated buffer.\n        // for (let i = 0; i < argv.length; i++) {\n        //     const size$arg = this.libFaust.lengthBytesUTF8(argv[i]) + 1;\n        //     const $arg = this.libFaust._malloc(size$arg);\n        //     this.libFaust.stringToUTF8(argv[i], $arg, size$arg);\n        //     argvBuffer$[i] = $arg;\n        // }\n        let argsStr = utils.argsTbl2String(argvIn) + \" -cn \" + factoryName;\n        try {\n            const time1 = performance.now();\n            this.log(\"createDSPFactory args : \" + argsStr);\n            let fact = this.libFaust.createDSPFactory(\"FaustDSP\", code, argsStr, internalMemory);\n            const time2 = performance.now();\n            this.log(\"Faust compilation duration : \" + (time2 - time1));\n            this.log(\"module : \" + fact.module + \" error: \" + fact.error);\n            if (fact.error) throw new Error(fact.error);\n\n            if (fact.module === 0) return null;\n\n            this.log(\"getWasmModule\");\n            let wasm = this.libFaust.getWasmModule(fact.module);\n            // Copy native 'binary' string in JavaScript Uint8Array\n            const ui8Code = new Uint8Array(wasm.size);\n            for (let i = 0; i < wasm.size; i++) {\n                // faster than 'getValue' which gets the type of access for each read...\n                ui8Code[i] = this.libFaust.HEAP8[wasm.module + i];\n            }\n            // Free C allocated wasm module\n            this.libFaust.freeWasmModule(wasm.module);\n            return { ui8Code, code, helpersCode: wasm.helper };\n\n            // const time1 = performance.now();\n            // const $moduleCode = this.createWasmCDSPFactoryFromString($name, $code, argv.length, $argv, $errorMsg, internalMemory);\n            // const time2 = performance.now();\n            // this.log(\"Faust compilation duration : \" + (time2 - time1));\n            // const errorMsg = this.libFaust.UTF8ToString($errorMsg);\n            // if (errorMsg) throw new Error(errorMsg);\n\n            // if ($moduleCode === 0) return null;\n            // const $compiledCode = this.getWasmCModule($moduleCode);\n            // const compiledCodeSize = this.getWasmCModuleSize($moduleCode);\n            // // Copy native 'binary' string in JavaScript Uint8Array\n            // const ui8Code = new Uint8Array(compiledCodeSize);\n            // for (let i = 0; i < compiledCodeSize; i++) {\n            //     // faster than 'getValue' which gets the type of access for each read...\n            //     ui8Code[i] = this.libFaust.HEAP8[$compiledCode + i];\n            // }\n            // const $helpersCode = this.getWasmCHelpers($moduleCode);\n            // const helpersCode = this.libFaust.UTF8ToString($helpersCode);\n            // // Free strings\n            // this.libFaust._free($code);\n            // this.libFaust._free($name);\n            // this.libFaust._free($errorMsg);\n            // // Free C allocated wasm module\n            // this.freeWasmCModule($moduleCode);\n            // // Get an updated integer view on the newly allocated buffer after possible emscripten memory grow\n            // argvBuffer$ = new Int32Array(this.libFaust.HEAP32.buffer, $argv, argv.length);\n            // // Free 'argv' C side array\n            // for (let i = 0; i < argv.length; i++) {\n            //     this.libFaust._free(argvBuffer$[i]);\n            // }\n            // this.libFaust._free($argv);\n            // return { ui8Code, code, helpersCode };\n        } catch (e) {\n            // libfaust is compiled without C++ exception activated, so a JS exception is throwed and catched here\n            const errorMsg = this.libFaust.getErrorAfterException();\n            this.libFaust.cleanupAfterException();\n            // Report the Emscripten error\n            throw errorMsg ? new Error(errorMsg) : e;\n        }\n    }\n    /**\n     * createDSPFactoryAux\n     * Generate shaKey, effects, dsp, their Wasm Modules and helpers from a dsp source code\n     *\n     * @private\n     * @param {string} code - dsp source code\n     * @param {string[]} argv - Array of paramaters to be given to the Faust compiler\n     * @param {boolean} internalMemory - Use internal Memory flag, false for poly, true for mono\n     * @returns {Promise<TCompiledDsp>} - An object contains shaKey, empty polyphony map, original codes, modules and helpers\n     * @memberof Faust\n     */\n    private async compileCodes(code: string, argv: string[], internalMemory: boolean): Promise<TCompiledDsp> {\n        // Code memory type and argv in the SHAKey to differentiate compilation flags and Monophonic and Polyphonic factories\n        const strArgv = argv.join(\"\");\n        const shaKey = sha1.hash(code + (internalMemory ? \"internal_memory\" : \"external_memory\") + strArgv, { msgFormat: \"string\" });\n        const compiledDsp = this.dspTable[shaKey];\n        if (compiledDsp) {\n            this.log(\"Existing library : \" + shaKey);\n            // Existing factory, do not create it...\n            return compiledDsp;\n        }\n        // this.log(\"libfaust.js version : \" + this.getLibFaustVersion());\n        this.log(\"libfaust.js version : \" + this.libFaust.version());\n        // Create 'effect' expression\n        const effectCode = `adapt(1,1) = _; adapt(2,2) = _,_; adapt(1,2) = _ <: _,_; adapt(2,1) = _,_ :> _;\nadaptor(F,G) = adapt(outputs(F),inputs(G));\ndsp_code = environment{${code}};\nprocess = adaptor(dsp_code.process, dsp_code.effect) : dsp_code.effect;`;\n        const dspCompiledCode = this.compileCode(shaKey, code, argv, internalMemory);\n        let effectCompiledCode: TCompiledCode;\n        try {\n            effectCompiledCode = this.compileCode(shaKey + \"_\", effectCode, argv, internalMemory);\n        } catch (e) {} // eslint-disable-line no-empty\n        const compiledCodes = { dsp: dspCompiledCode, effect: effectCompiledCode };\n        return this.compileDsp(compiledCodes, shaKey);\n    }\n    /**\n     * From a DSP source file, creates a \"self-contained\" DSP source string where all needed librairies have been included.\n     * All compilations options are 'normalized' and included as a comment in the expanded string.\n     *\n     * @param {string} code - dsp source code\n     * @param {TFaustCompileArgs} args - Paramaters to be given to the Faust compiler\n     * @returns {string} \"self-contained\" DSP source string where all needed librairies\n     * @memberof Faust\n     */\n    expandCode(code: string, args?: TFaustCompileArgs): string {\n        this.log(\"libfaust.js version : \" + this.libFaust.version());\n        // Allocate strings on the HEAP\n        // const codeSize = this.libFaust.lengthBytesUTF8(code) + 1;\n        // const $code = this.libFaust._malloc(codeSize);\n\n        // const name = \"FaustDSP\";\n        // const nameSize = this.libFaust.lengthBytesUTF8(name) + 1;\n        // const $name = this.libFaust._malloc(nameSize);\n\n        // const $shaKey = this.libFaust._malloc(64);\n        // const $errorMsg = this.libFaust._malloc(4096);\n\n        // this.libFaust.stringToUTF8(name, $name, nameSize);\n        // this.libFaust.stringToUTF8(code, $code, codeSize);\n\n        // const argvIn = args ? utils.toArgv(args) : [];\n        // // Force \"wasm\" compilation\n        // const argv = [...argvIn, \"-lang\", \"wasm\"];\n\n        const argsStr = utils.args2String(args) + \"-lang wasm\";\n\n        // Prepare 'argv' array for C side\n        // const ptrSize = 4;\n        // const $argv = this.libFaust._malloc(argv.length * ptrSize); // Get buffer from emscripten.\n        // let argvBuffer$ = new Int32Array(this.libFaust.HEAP32.buffer, $argv, argv.length); // Get a integer view on the newly allocated buffer.\n        // for (let i = 0; i < argv.length; i++) {\n        //     const size$arg = this.libFaust.lengthBytesUTF8(argv[i]) + 1;\n        //     const $arg = this.libFaust._malloc(size$arg);\n        //     this.libFaust.stringToUTF8(argv[i], $arg, size$arg);\n        //     argvBuffer$[i] = $arg;\n        // }\n        try {\n            let expand = this.libFaust.expandDSP(\"FaustDSP\", code, argsStr);\n            const expandedCode = expand.dsp;\n            const errorMsg = expand.error;\n            if (errorMsg) this.error(errorMsg);\n\n            // const $expandedCode = this.expandCDSPFromString($name, $code, argv.length, $argv, $shaKey, $errorMsg);\n            // const expandedCode = this.libFaust.UTF8ToString($expandedCode);\n            // const errorMsg = this.libFaust.UTF8ToString($errorMsg);\n            // if (errorMsg) this.error(errorMsg);\n            // Free strings\n            // this.libFaust._free($code);\n            // this.libFaust._free($name);\n            // this.libFaust._free($shaKey);\n            // this.libFaust._free($errorMsg);\n            // Free C allocated expanded string\n            // this.freeCMemory($expandedCode);\n            // Get an updated integer view on the newly allocated buffer after possible emscripten memory grow\n            // argvBuffer$ = new Int32Array(this.libFaust.HEAP32.buffer, $argv, argv.length);\n            // // Free 'argv' C side array\n            // for (let i = 0; i < argv.length; i++) {\n            //     this.libFaust._free(argvBuffer$[i]);\n            // }\n            // this.libFaust._free($argv);\n            return expandedCode;\n        } catch (e) {\n            // libfaust is compiled without C++ exception activated, so a JS exception is throwed and catched here\n            const errorMsg = this.libFaust.getErrorAfterException();\n            this.libFaust.cleanupAfterException();\n\n            // const errorMsg = this.libFaust.UTF8ToString(this.getErrorAfterException());\n            // this.cleanupAfterException();\n            // Report the Emscripten error\n            throw errorMsg ? new Error(errorMsg) : e;\n        }\n    }\n    /**\n     * readDSPFactoryFromMachineAux\n     * Compile wasm modules from dsp and effect Uint8Arrays\n     *\n     * @private\n     * @param {TCompiledCodes} codes\n     * @param {string} shaKey\n     * @returns {Promise<TCompiledDsp>}\n     * @memberof Faust\n     */\n    private async compileDsp(codes: TCompiledCodes, shaKey: string): Promise<TCompiledDsp> {\n        const time1 = performance.now();\n        /*\n        if (typeof Binaryen !== \"undefined\") {\n            try {\n                const binaryenModule = Binaryen.readBinary(codes.dsp.ui8Code);\n                this.log(\"Binaryen based optimisation\");\n                binaryenModule.optimize();\n                // console.log(binaryen_module.emitText());\n                codes.dsp.ui8Code = binaryenModule.emitBinary();\n                binaryenModule.dispose();\n            } catch (e) {\n                this.log(\"Binaryen not available, no optimisation...\");\n            }\n        }\n        */\n        const dspModule = await WebAssembly.compile(codes.dsp.ui8Code);\n        if (!dspModule) {\n            this.error(\"Faust DSP factory cannot be compiled\");\n            throw new Error(\"Faust DSP factory cannot be compiled\");\n        }\n        const time2 = performance.now();\n        this.log(\"WASM compilation duration : \" + (time2 - time1));\n        const compiledDsp: TCompiledDsp = { shaKey, codes, dspModule, dspMeta: undefined }; // Default mode\n        // 'libfaust.js' wasm backend generates UI methods, then we compile the code\n        // eval(helpers_code1);\n        // factory.getJSON = eval(\"getJSON\" + dspName);\n        // factory.getBase64Code = eval(\"getBase64Code\" + dspName);\n        try {\n            const json = codes.dsp.helpersCode.match(/getJSON\\w+?\\(\\)[\\s\\n]*{[\\s\\n]*return[\\s\\n]*'(\\{.+?)';}/)[1].replace(/\\\\'/g, \"'\");\n            // const base64Code = codes.dsp.helpersCode.match(/getBase64Code\\w+?\\(\\)[\\s\\n]*{[\\s\\n]*return[\\s\\n]*\"([A-Za-z0-9+/=]+?)\";[\\s\\n]+}/)[1];\n            const meta = JSON.parse(json);\n            compiledDsp.dspMeta = meta;\n        } catch (e) {\n            this.error(\"Error in JSON.parse: \" + e.message);\n            throw e;\n        }\n        this.dspTable[shaKey] = compiledDsp;\n        // Possibly compile effect\n        if (!codes.effect) return compiledDsp;\n        try {\n            const effectModule = await WebAssembly.compile(codes.effect.ui8Code);\n            compiledDsp.effectModule = effectModule;\n            // 'libfaust.js' wasm backend generates UI methods, then we compile the code\n            // eval(helpers_code2);\n            // factory.getJSONeffect = eval(\"getJSON\" + factory_name2);\n            // factory.getBase64Codeeffect = eval(\"getBase64Code\" + factory_name2);\n            try {\n                const json = codes.effect.helpersCode.match(/getJSON\\w+?\\(\\)[\\s\\n]*{[\\s\\n]*return[\\s\\n]*'(\\{.+?)';}/)[1].replace(/\\\\'/g, \"'\");\n                // const base64Code = codes.effect.helpersCode.match(/getBase64Code\\w+?\\(\\)[\\s\\n]*{[\\s\\n]*return[\\s\\n]*\"([A-Za-z0-9+/=]+?)\";[\\s\\n]+}/)[1];\n                const meta = JSON.parse(json);\n                compiledDsp.effectMeta = meta;\n            } catch (e) {\n                this.error(\"Error in JSON.parse: \" + e.message);\n                throw e;\n            }\n        } catch (e) {\n            return compiledDsp;\n        }\n        return compiledDsp;\n    }\n    /**\n     * Get a ScriptProcessorNode from compiled dsp\n     *\n     * @private\n     * @param {TCompiledDsp} compiledDsp - DSP compiled by libfaust\n     * @param {TAudioNodeOptions} optionsIn\n     * @returns {Promise<FaustScriptProcessorNode>}\n     * @memberof Faust\n     */\n    private async getScriptProcessorNode(optionsIn: TAudioNodeOptions): Promise<FaustScriptProcessorNode> {\n        return new FaustWasmToScriptProcessor(this).getNode(optionsIn);\n    }\n    // deleteDSPInstance() {}\n    /**\n     * Get a AudioWorkletNode from compiled dsp\n     *\n     * @private\n     * @param {TAudioNodeOptions} optionsIn\n     * @returns {Promise<FaustAudioWorkletNode>}\n     * @memberof Faust\n     */\n    private async getAudioWorkletNode(optionsIn: TAudioNodeOptions): Promise<FaustAudioWorkletNode> {\n        const { compiledDsp: compiledDspWithCodes, audioCtx, voices, plotHandler } = optionsIn;\n        const compiledDsp = { ...compiledDspWithCodes };\n        delete compiledDsp.codes;\n        const id = compiledDsp.shaKey + \"_\" + voices;\n        if (this.workletProcessors.indexOf(id) === -1) {\n            const strProcessor = `\nconst remap = ${utils.remap.toString()};\nconst midiToFreq = ${utils.midiToFreq.toString()};\nconst findPath = (${utils.findPathClosure.toString()})();\nconst createWasmImport = ${utils.createWasmImport.toString()};\nconst createWasmMemory = ${utils.createWasmMemory.toString()};\nconst faustData = ${JSON.stringify({\n        id,\n        voices,\n        dspMeta: compiledDsp.dspMeta,\n        effectMeta: compiledDsp.effectMeta\n    })};\n(${FaustAudioWorkletProcessorWrapper.toString()})();\n`;\n            const url = window.URL.createObjectURL(new Blob([strProcessor], { type: \"text/javascript\" }));\n            await audioCtx.audioWorklet.addModule(url);\n            this.workletProcessors.push(id);\n        }\n        return new FaustAudioWorkletNode({ audioCtx, id, voices, compiledDsp, plotHandler, mixer32Module: utils.mixer32Module });\n    }\n    /**\n     * Remove a DSP from registry\n     *\n     * @private\n     * @param {TCompiledDsp} compiledDsp\n     * @memberof Faust\n     */\n    private deleteDsp(compiledDsp: TCompiledDsp): void {\n        // The JS side is cleared\n        delete this.dspTable[compiledDsp.shaKey];\n        // The native C++ is cleared each time (freeWasmCModule has been already called in faust.compile)\n        this.libFaust.deleteAllDSPFactories();\n        // this.deleteAllWasmCDSPFactories();\n    }\n    /**\n     * Stringify current storaged DSP Table.\n     *\n     * @returns {string}\n     * @memberof Faust\n     */\n    stringifyDspTable(): string {\n        const strTable: { [shaKey: string]: TCompiledStrCodes } = {};\n        for (const key in this.dspTable) {\n            const { codes } = this.dspTable[key];\n            strTable[key] = {\n                dsp: {\n                    strCode: btoa(utils.ab2str(codes.dsp.ui8Code)),\n                    code: codes.dsp.code,\n                    helpersCode: codes.dsp.helpersCode\n                },\n                effect: codes.effect ? {\n                    strCode: btoa(utils.ab2str(codes.effect.ui8Code)),\n                    code: codes.effect.code,\n                    helpersCode: codes.effect.helpersCode\n                } : undefined\n            };\n        }\n        return JSON.stringify(strTable);\n    }\n    /**\n     * parse and store a stringified DSP Table.\n     *\n     * @param {string} str\n     * @memberof Faust\n     */\n    parseDspTable(str: string) {\n        const strTable = JSON.parse(str) as { [shaKey: string]: TCompiledStrCodes };\n        for (const shaKey in strTable) {\n            if (this.dspTable[shaKey]) continue;\n            const strCodes = strTable[shaKey];\n            const compiledCodes: TCompiledCodes = {\n                dsp: {\n                    ui8Code: utils.str2ab(atob(strCodes.dsp.strCode)),\n                    code: strCodes.dsp.code,\n                    helpersCode: strCodes.dsp.helpersCode\n                },\n                effect: strCodes.effect ? {\n                    ui8Code: utils.str2ab(atob(strCodes.effect.strCode)),\n                    code: strCodes.effect.code,\n                    helpersCode: strCodes.effect.helpersCode\n                } : undefined\n            };\n            this.compileDsp(compiledCodes, shaKey).then(dsp => this.dspTable[shaKey] = dsp);\n        }\n    }\n    // deleteDSPWorkletInstance() {}\n    /**\n     * Get an SVG Diagram XML File as string\n     *\n     * @param {string} code faust source code\n     * @param {TFaustCompileArgs} args - Paramaters to be given to the Faust compiler\n     * @returns {string} svg file as string\n     * @memberof Faust\n     */\n    getDiagram(code: string, args?: TFaustCompileArgs): string {\n        // const codeSize = this.libFaust.lengthBytesUTF8(code) + 1;\n        // const $code = this.libFaust._malloc(codeSize);\n        // const name = \"FaustDSP\";\n        // const nameSize = this.libFaust.lengthBytesUTF8(name) + 1;\n        // const $name = this.libFaust._malloc(nameSize);\n        // const $errorMsg = this.libFaust._malloc(4096);\n\n        // this.libFaust.stringToUTF8(name, $name, nameSize);\n        // this.libFaust.stringToUTF8(code, $code, codeSize);\n        // const argvIn = args ? utils.toArgv(args) : [];\n        // const argv = [...argvIn, \"-lang\", \"wast\", \"-o\", \"/dev/null\", \"-svg\"];\n\n        // // Prepare 'argv' array for C side\n        // const ptrSize = 4;\n        // const $argv = this.libFaust._malloc(argv.length * ptrSize); // Get buffer from emscripten.\n        // let argvBuffer$ = new Int32Array(this.libFaust.HEAP32.buffer, $argv, argv.length); // Get a integer view on the newly allocated buffer.\n        // for (let i = 0; i < argv.length; i++) {\n        //     const size$arg = this.libFaust.lengthBytesUTF8(argv[i]) + 1;\n        //     const $arg = this.libFaust._malloc(size$arg);\n        //     this.libFaust.stringToUTF8(argv[i], $arg, size$arg);\n        //     argvBuffer$[i] = $arg;\n        // }\n\n        const argsStr = utils.args2String(args) + \"-lang wasm -o /dev/null -svg\";\n        try {\n            let aux = this.libFaust.generateAuxFiles(\"FaustDSP\", code, argsStr);\n\n            // this.generateCAuxFilesFromString($name, $code, argv.length, $argv, $errorMsg);\n            // // Free strings\n            // this.libFaust._free($code);\n            // this.libFaust._free($name);\n            // this.libFaust._free($errorMsg);\n            // // Get an updated integer view on the newly allocated buffer after possible emscripten memory grow\n            // argvBuffer$ = new Int32Array(this.libFaust.HEAP32.buffer, $argv, argv.length);\n            // // Free 'argv' C side array\n            // for (let i = 0; i < argv.length; i++) {\n            //     this.libFaust._free(argvBuffer$[i]);\n            // }\n            // this.libFaust._free($argv);\n        } catch (e) {\n            // libfaust is compiled without C++ exception activated, so a JS exception is throwed and catched here\n            // const errorMsg = this.libFaust.UTF8ToString(this.getErrorAfterException());\n            const errorMsg = this.libFaust.getErrorAfterException();\n            this.libFaust.cleanupAfterException();\n            // Report the Emscripten error\n            throw errorMsg ? new Error(errorMsg) : e;\n        }\n        return this.libFaust.FS.readFile(\"FaustDSP-svg/process.svg\", { encoding: \"utf8\" }) as string;\n    }\n    /**\n     * Expose LibFaust Emscripten Module File System\n     *\n     * @param {string} path path string\n     * @returns {Emscripten.FS} Emscripten Module File System\n     * @memberof Faust\n     */\n    get fs() {\n        return this.libFaust.FS;\n    }\n    log(...args: any[]) {\n        if (this.debug) console.log(...args);\n        const msg = args.length === 1 && typeof args[0] === \"string\" ? args[0] : JSON.stringify(args.length !== 1 ? args : args[0]);\n        this._log.push(msg);\n        if (typeof this.logHandler === \"function\") this.logHandler(msg, 0);\n    }\n    error(...args: any[]) {\n        console.error(...args);\n        const msg = args.length === 1 && typeof args[0] === \"string\" ? args[0] : JSON.stringify(args.length !== 1 ? args : args[0]);\n        this._log.push(msg);\n        if (typeof this.logHandler === \"function\") this.logHandler(msg, 1);\n    }\n    logHandler: (msg: string, errorLevel: 1 | 0) => any;\n}\n"],"sourceRoot":""}